# 有哪些常见的数值类？

简单值类型：包括 整数类型、实数类型、字符类型、布尔类型

复合值类型：包括 结构类型、枚举类型

# 有哪些主要的数据类型，他们之间是怎样转换的?

![img](E:\Typora_MD\Image\Center.png)

- 隐式类型转换
- 强制类型转换
- 类型转换方法：Convert类
- as运算符

# C#中基本类型占用的字节数

![image-20231017195106056](E:\Typora_MD\Image\image-20231017195106056.png)


# OOP
## 类和对象的区别？

类相当于一个蓝图（模板），new一个对象，就是按照蓝图（模板），创建对应的多个东西。

## 静态类和非静态类的区别？

静态类不能实例化！静态类中只能包含 静态成员（构造方法、字段、属性）！

非静态需要实例化才能使用。

## 静态字段和非静态字段的区别？

以static标识区分，静态字段可以直接以类名.字段名方式使用，而非静态字段必须创建类实例才可以使用。
## 面向对象OOP的特性有哪些？结合具体案例说一下。
## C# 面向对象的三大特性

### 封装 （抽象）

根据一个功能创建一个类，里面包括 数据（字段/属性） 和 操作数据的方法。

另一个类来调用这个类，我们不需要了解这个类内部的具体实现，只要知道可以用这个类实现某个功能。

也就是通过封装隐藏这个类内部的实现细节，降低类使用的学习使用成本，降低复杂度；

### 继承

一个类（基类） 派生出子类 ， 子类会继承父类的属性和方法，还可以重写父类方法。

也就是 重用现有代码。

### 多态 （动态绑定 - 在运行时决定）

概念上讲是：同一个行为具有多个不同表现形式

父类引用指向子类对象，通过调用相同的方法，根据不同的子类实现不同的功能

> 静态多态重载，动态多态重写

## C#支持多重继承吗？

单继承，多实现。

## override 重写 和 overload 重载 的区别

重写 是 继承父类的方法，可以保持默认也可以覆盖成子类独有的方法。

重载 是 方法名相同参数列表不同，使用时根据参数列表不同来调用；

重载时编译时多态，重写是运行时多态。

## 方法重写override和方法隐藏new有什么区别？

在子类重写父类方法，可以保持默认也可以覆盖成子类独有的方法（运行时，改写了方法表的新地址）。

而重写后把 override关键字 改成 new 就是隐藏子类方法，去执行父类里面的方法内容；

## 重载的原因

同名方法根据不同的参数[集合](https://so.csdn.net/so/search?q=集合&spm=1001.2101.3001.7020)达到相同的功能


## 结构体和类有什么区别

1. 结构体是值类型  ， 类是引用类型。这意味着结构体在赋值和传递时直接复制其值，而类在赋值和传递时复制引用（地址）。
2. 结构体存储在栈空间，类 存储在堆空间 。由于栈上的操作速度更快，结构体在某些情况下可能比类更高效。
3. 类会自动生成默认的无参数构造函数，而结构体不会。结构体在构造函数中需要初始化所有成员变量 ； 类随意
4. 类支持继承和实现多个接口，而结构体只能实现接口，不支持继承。
5. 类的成员默认访问修饰符是`private`，而结构体的成员默认访问修饰符是`public`。
6. *由于结构体是值类型，当需要将其作为对象传递给.NET框架中的某些方法时，会发生装箱操作。这会导致性能损耗。*



1. 结构体是值类型，类是引用类型。
2. 结构体存在栈中，类存在堆中。
3. 结构体变量和类对象进行类型传递时,结构体变量进行的就是值传递,而类对象进行的是引用传递，或者说传递的是指针,这样在函数中改变参数值,结构体对象的值是不变的,而类对象的值是变化了。
4. 在C#中结构体类型定义时，成员是不能初始化的,这样就导致了，定义结构体变量时,变量的所有成员都要自己赋值初始化。但对于类，在定义类时,就可以初始化其中的成员变量,所以在定义对象时,对象本身就已经有了初始值,你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)
5. 结构体不能申明无参的构造函数，而类可以。
6. 声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。
7. 结构体申明有参构造函数后，无参构造不会被顶掉。
8. 结构体不能申明析构函数，而类可以。
9. 结构体不能被继承，而类可以。
10. 结构体需要在构造函数中初始化所有成员变量，而类随意。
11. 结构体不能被静态static修饰(不存在静态结构体)，而类可以。
    


## 如何选择结构体和类

1. 想要使用继承和多态特性时，直接使用类，比如 玩家，敌人...
2. 对象是数据集合，优先考虑结构体，比如位置、坐标...
3. 从值类型和引用类型赋值的区别上去考虑，比如 经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，用结构体，比如坐标、向量、旋转...

结构体：

结构体是值类型在栈中，栈的存取速度比堆快，但是容量小，适合轻量级的对象，比如点、矩形、颜色。
如果对象是数据集合时，优先考虑接结构体（位置，坐标）
在变量传值的时候，希望传递对象的是拷贝，而不是对象的引用地址，这个时候就可以使用结构体。

————————————————

类：

类是引用类型，存储在堆中，堆的容量大，适合重量级的对象，栈的空间不大，大量的对应当存在于堆中。
如果对象需要继承和多态特征，用类（玩家、怪物）。

## 虚方法、抽象方法 区别

### 虚函数实现原理
每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。
那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。



子类都可以重写方法

### 虚方法

修饰符：virtual

可以有方法体，有自己的实现

子类可以选择是否重写方法

可以在抽象类和非抽象类中

### 抽象方法 

修饰符：abstract

没有方法体

子类必须重写

必须在抽象类中

## 抽象类、接口区别

概念

抽象类

当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类不能被实例化，就可以把这个基类设计成抽象类。
当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。
接口

当注重代码的扩展性跟可维护性时，应当优先采用接口。
接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活;
接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。
区别

1. 接口不是类（无构造函数和析构函数），不能被实例化，抽象类可以间接实例化（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。
2. 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。
3. 抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是完全抽象，抽象类是部分抽象。
4. 抽象类要被子类继承，接口要被类实现。
5. 抽象类中所有的成员修饰符都能使用，接口中的成员都是对外的，所以不需要修饰符修饰。
6. 接口可以实现多继承，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口。
7. 抽象方法要被实现，所以不能是静态的，也不能是私有的。

**使用情形**

使用抽象类是为了代码的复用，而使用接口的动机是为了实现多态性。
抽象类适合用来定义某个领域的固有属性，也就是本质，接口适合用来定义某个领域的扩展功能。



接口是一种行为，抽象类是一种不能实例化的对象。
接口interface可以定义方法、属性、索引器、事件
抽象类abstract可以定义字段、静态字段和方法、抽象方法、属性、构造函数
接口可以继承多个接口，抽象类只能继承一个类
接口直接实现所有成员，抽象类重写override抽象方法
接口和抽象都不能被实例化，派生类必须实现基类或接口的方法
抽象类可以派生自另一个抽象类，接口可以多重实现，抽象类只能单一继承
举个例子：抽象类门，多接口继承【可破坏、金属】的行为方法，派生类实例化这个门，接口的实现类实现具体行为，派生类创建这样具体的可破坏的铁门
[【精选】【C# 教程系列第 15 篇】抽象类与接口的区别_抽象类中不包含任何实现-CSDN博客](https://blog.csdn.net/qq_42351033/article/details/87540068?ops_request_misc=%7B%22request%5Fid%22%3A%22160632773419724848160870%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=160632773419724848160870&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-87540068.first_rank_ecpm_v3_pc_rank_v2&utm_term=C%23抽象类和接口的区别&spm=1018.2118.3001.4449)

### 接口



### 抽象类



语法不同处：

抽象类中可以有字段，接口没有。
抽象类中可以有实现成员，接口只能包含抽象成员。
抽象类中所有成员修饰符都可以使用，接口中所有的成员都是对外的，所以不需要修饰符修饰。

用法不同处：

抽象类是概念的抽象，接口关注于行为。
抽象类的子类与父类的关系是泛化关系，耦合度较高，而实现类和接口之间是实现的关系，耦合度比泛化低。
一个类只能继承一个类，但是可以实现多个接口。


## 如何选择抽象类和接口

表示对象的用抽象类，表示行为拓展的用接口；

不同对象拥有共同的行为，使用接口；

举例：

动物是一类对象，选择抽象类；飞是行为，选择接口；

## 什么是接口，描述一下接口的成员具体实现

接口interface，不能定义字段，可以定义【非静态的】属性、索引器、事件、方法
默认public，但不能写任何访问修饰符
接口是引用类型，可以通过as运算符强转，获取某对象的接口的引用
接口可以继承N个接口，继承类要实现所有接口的方法

声明接口IA > 继承接口的类B > 类B实现接口所有方法
接口要小而精，定义一组方法，继承接口的派生类要实现接口的所有方法。
接口和抽象类是不能被实例化的对象（引用类型）

```C#
public delegate void DelegateTest();
    public interface ITest //只能包含非静态成员函数，隐式public，但不允许访问修饰符
    {
        void Method(string a); //方法
        string Property //属性
        {
            get; set;
        }
        event DelegateTest EventTest; //事件，需要先定义一个委托
        int this[int index] //索引器
        {
            get; set;
        }
    }

```

举个例子：游戏门：抽象类，不能实例，很多行为，定义接口，破坏可以击碎
系统接口鼠标行为，停留进入离开
很多设计模式，是对接口的应用，面向接口编程，实现层面更加有层次。
【参考C#图解第十五章接口】

## 接口声明主要有几部分组成？



## 接口中的默认实现是什么？



## 在某些场合使用接口而不是类继承，为什么？



## 请描述interface和抽象类之间的不同



## 接口和类的继承区别



## 什么是静态类？



## 静态构造函数

1. 静态构造函数既没有访问修饰符，也没有参数。
2. 在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。
3. 一个类只能有一个静态构造函数。
4. 无参数的构造函数可以与静态构造函数共存。
5. 最多只运行一次。
6. 静态构造函数不可以被继承。
7. 如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会自动生成默认的静态构造函数。
8. 如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。

## 在类的构造函数前加上 static 会报什么错?为什么?

静态构造函数不允许添加访问修饰符，且必须无参数
原因：无论创建多少类型的对象，静态构造函数只执行一次
类实例化或者首静态成员调用之前，运行库会先调用静态构造函数
静态构造函数优先级高于任何其它构造函数
也无法使用this和base来调用静态构造函数
一个类只能有一个静态函数，如果有静态变量，系统也会自动生成静态函数

## 什么是扩展方法？
## 什么是部分类？
## lambda表达式的作用
## lambda什么情况下产生闭包


## 关键字与修饰符
### C#中四种访问修饰符是哪些？各有什么区别？

1. **属性修饰符**
2. **存取修饰符**
3. **类修饰符**
4. **成员修饰符**

属性修饰符：
Serializable：按值将对象封送到远程服务器。
STATread：是单线程套间的意思，是⼀种线程模型。
MATAThread：是多线程套间的意思，也是⼀种线程模
型。

存取修饰符：
public：存取不受限制。
private：只有包含该成员的类可以存取。
internal：只有当前⼯程可以存取。
protected：只有包含该成员的类以及派⽣类可以存
取。

类修饰符：
abstract：抽象类。指示⼀个类只能作为其它类的基
类。
sealed：密封类。指示⼀个类不能被继承。理所当
然，密封类不能同时⼜是抽象类，因为抽象总是希望
被继承的。

成员修饰符：
abstract：指示该⽅法或属性没有实现。
sealed：密封⽅法。可以防⽌在派⽣类中对该⽅法的
override（᯿载）。不是类的每个成员⽅法都可以作为
密封⽅法密封⽅法，必须对基类的虚⽅法进⾏᯿载，
提供具体的实现⽅法。所以，在⽅法的声明中，
sealed修饰符总是和override修饰符同时使⽤。
delegate：委托。⽤来定义⼀个函数指针。C#中的事
件驱动是基于delegate + event的。
const：指定该成员的值只读不允许修改。
event：声明⼀个事件。
extern：指示⽅法在外部实现。
override：᯿写。对由基类继承成员的新实现。
readonly：指示⼀个域只能在声明时以及相同类的内
部被赋值。
static：指示⼀个成员属于类型本身，⽽不是属于特定
的对象。即在定义后可不经实例化，就可使⽤。
virtual：指示⼀个⽅法或存取器的实现可以在继承类中
被覆盖。
new：在派⽣类中隐藏指定的基类成员，从⽽实现᯿
写的功能。 若要隐藏继承类的成员，请使⽤相同名称
在派⽣类中声明该成员，并⽤ new 修饰符修饰它。

### C# 中的默认访问修饰符是什么？

###  public、private、protected、internal、sealed的区别

public全局、private类内部、protected派生类、internal本程序集
sealed声明类就不能继承，声明方法就是不能被重写

- public：对任何类和成员都公开，无限制访问
- private：仅对该类公开
- protected：对该类和其派生类公开
- internal：只能在包含该类的程序集中访问该类
- protected internal：protected + internal

###  ”const”和“readonly”修饰符有什么区别？

### “is”和“as”关键字有什么区别？

### “static”关键字的用途是什么？

### “new”关键字有什么作用？



### New 的实现逻辑：

rPoint1 = new RefPoint(1);

1. 在应用程序堆上创建一个引用类型对象的实例，并为它分配内存地址。
2. 自动传递该实例的引用给构造函数(正因如此，在构造函数中才能使用this来访问这个实例)。
3. 调用该类型的构造函数。
4. 返回该实例的引用内存地址，复制给 rPoint1 变量，该rPoint1 引用对象保存的数据是指向在堆上创建该类型的实例地址。

### “dynamic”关键字的目的是什么？

### 双精度double和小数decimal有什么区别？

### using的作用 （ “using”关键字有什么用？）

资源：实现了IDisposable接口的类或结构。
using语句确保这些资源能够被适当的释放（Resource.Dispose）
using原理
using（分配资源）{ 使用资源 } ——> 释放资源 （隐式）
使用资源（可能会导致异常）会被放进Try块里，释放资源（有无异常）都会放进在finally块

```c#
using（分配资源）
{
	try{ 使用资源 }
	finally{ Resource.Dispose}
}
```

using指令,using+命名空间（或命名空间一个类型） 在源文件的顶端声明
也可以不使用using，直接命名空间.类.成员方法

### C#中ref和out关键字有什么区别？知道Ref的深层原理是什么？

ref修饰引用参数。参数必须赋值，带回返回值，又进又出
out修饰输出参数。参数可以不赋值，带回返回值之前必须明确赋值，
引用参数和输出参数不会创建新的存储位置

如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变，
如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据会改变，如果对引用类型再次创建新对象并赋值给ref参数，引用地址会重新指向新对象堆数据。方法结束后形参和新对象都会消失。实参还是指向原始对象，值不够数据改变了
【参考C#图解教程：引用类型作为值参数和引用参数】

### “sealed密封”修饰符的用途是什么？

类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。

### 三元条件运算符的用途是什么？

### 相等运算符（==）和Equals有什么区别？

### 什么是运算符重载？

### 什么是特性attributes？

### 什么是序列化与反序列化 serialization？

### “params”关键字的用途是什么？

### 空合并和空条件运算符的目的是什么？

### 什么是属性property？

### 什么是nullable可空类型？什么是可空引用类型nullable reference types？

### New的实现逻辑

### C#中unsafe关键字是用来做什么的？什么场合下使用？

unsafe 非托管代码，配合fixed一起使用 ，用在需要指针操作的场合
项目背包系统的任务装备栏使用到

### 为什么使用“goto”关键字被认为是一种不好的做法？

### 元组和值元组有什么区别？

### 什么是匿名类型？

### “checked”关键字的目的是什么？



## Mathf.Round和Mathf.Clamp和Mathf.Lerp含义？

Mathf.Round：四舍五入
Mathf.Clamp：左右限值
Mathf.Lerp：插值

## 什么是 immutable types不可变类型以及它们的目的是什么？
## Dispose 和 Finalize 方法有什么区别？


# 值类型和引用类型
## C#中所有引用类型的基类是什么

System.Object

引用类型的基类是System.Object

值类型的基类是 System.ValueType。

同时，值类型也隐式继承自System.Object。

## 值类型和引用类型区别

值类型：包含了所有简单类型（整数、浮点、bool、char）、struct、enum。
`继承自System.ValueTyoe`
引用类型包含了string，object，class，interface，delegate，array
`继承自System.Object`

1. 值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。
2. 值类型存取快，引用类型存取慢。
3. 值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。
4. 栈的内存是自动释放的，堆内存是.NET 中会由 GC 来自动释放。
5. 值类型继承自 System.ValueType,引用类型继承自 System.Object。
6. 值类型在栈中存储的是直接的值，引用类型数据本身实在堆中，栈中存放的是一个引用的地址。

### 拷贝策略

如果值类型为传值参数，传值参数会在栈上新开辟一个副本，原先的值类型数据不会改变
如果引用类型是传值参数，传值参数会创建一个新的引用地址，两个引用地址会指向同一个对象实例的数据，实例数据会随着改变进行改变。（这种行为被称为副作用，一般实际项目不会这么操作，要么return返回参数，要么使用ref或者out修饰符）
【扩展Ref引用参数，Out输出参数可以利用这一副作用机制】

> 通常来讲 变量的值分配 与其声明该变量的位置有关。 局部变量的值 总是在 栈上的。 实例变量的值则和实例本身一起储存在实例储存的地方。 引用类型实例和静态总是储存在 堆上的。
> 数组的元素、引用类型中的值类型字段等，引用类型的确总是分配在托管堆上， 但是值类型并非总是分配在线程栈上有可能分配在堆上。

## 深拷贝和浅拷贝有什么区别？

##  栈空间、堆空间的区别 (Heap与Stack有何区别?)

通常保存着我们代码执行的步骤，如在代码段1中 AddFive()方法，int pValue变量，int result变量等等。 而堆上存放的则多是对象，数据等。(译者注:忽略编 译器优化)我们可以把栈想象成一个接着一个叠放在 一起的盒子。当我们使用的时候，每次从最顶部取走 一个盒子。
栈也是如此，当一个方法(或类型)被调 用完成的时候，就从栈顶取走(called a Frame，译 注:调用帧)，接着下一个。堆则不然，像是一个仓 库，储存着我们使用的各种对象等信息，跟栈不同的 是他们被调用完毕不会立即被清理掉。

1. GC方面：栈保持着先进后出的原则，是一片连续的内存域，有系统自动分配和维护，产生的垃圾系统自动释放。而堆是无序的，他是一片不连续的内存域，用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC)来回收。
2. 存储方面：栈通常保存着我们代码执行的步骤，如方法变量等等。而堆上存放的则多是对象，数据等。我们可以把栈想象成一个接着一个叠放在一起的盒子(越高内存地址越低)。当我们使用的时候，每次从最顶部取走一个盒子，当一个方法（或类型）被调用完成的时候，就从栈顶取走接着下一个。堆则不然，像是一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉。
3. 缓存方面：栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放;堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收)。所以调用这些对象的速度要相对来得低一些。
4. 存储方面：栈(Stack)是一种先进后出的数据结构，在内存中，变量会被分配在栈上来进行操作。堆(heap)是用于为引用类型的实例(对象),分配空间的内存区域，在堆上创建一个对象，会将对象的地址传给栈上的变量(反过来叫变量指向此对象，或者变量引用此对象)-----也就是栈上的变量指向了堆上地址为XXX的实例(对象)。
   

## 栈溢出一般是由什么原因导致

## 什么是装箱拆箱，怎样减少操作

C#装箱是将值类型转换为引用类型；
拆箱是将引用类型转换为值类型。
牵扯到装箱和拆箱操作比较多的就是在集合中，例如：ArrayList或者HashTable之类。

值类型和引用类型互相转换：拆箱和装箱
装箱：值类型====》引用类型object

1. 分配内存堆

2. 值类型数据拷贝到新的内存堆中

3. 栈中分配一个新的引用地址指向内存堆

   

   拆箱：引用类型object====》值类型

1. 检查确保对象是给定值类型的一个装箱值
2. 将该值数据复制到栈中的值类型
   

## 装箱和拆箱的区别  (值类型和引用类型互相转换)

装箱：值类型 > 引用类型object
1.分配内存堆
2.值类型数据拷贝到新的内存堆中
3.栈中分配一个新的引用地址指向内存堆
拆箱：引用类型object > 值类型
1.检查确保对象是给定值类型的一个装箱值
2.将该值数据复制到栈中的值类型

string是特殊的引用类型，如果传入参数是string，在方法里修改，原string数值不变。
原因是string的不变性，系统内部做了特殊处理。

[C#装箱和拆箱（Boxing 和 UnBoxing）_c#装箱拆箱-CSDN博客](https://blog.csdn.net/qiaoquan3/article/details/51439726?ops_request_misc=%7B%22request%5Fid%22%3A%22160628078719724836705812%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=160628078719724836705812&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-51439726.first_rank_ecpm_v3_pc_rank_v2&utm_term=C%23+拆箱+装箱&spm=1018.2118.3001.4449)

值类型和引用类型的最终基类是Object
装箱：值类型转换成引用类型的过程，生成新的引用
拆箱；引用类型转换成值类型的过程

装箱操作：托管堆分配内存，值类型拷贝数据，object地址指向托管堆对象
拆箱操作：根据object引用地址找到托管堆上的数据，栈上数据拷贝
避免装箱操作，生成新的应用，解决办法就是第一是重载，第二是泛型

## 数组是什么类型？字符串？接口？结构体里有引用类型，引用类型内存在什么地方开辟？结构体呢？有一个Class类，里面有IntIE在哪类型字段，分别在哪？值类型的基类？装箱操作实际发生了什么？

## 在函数里参数传递，值类型和引用类型的区别
##　值类型在函数的传参可以改变，该怎么做


# 容器类（基本数据结构类型、List 字典...）
## 什么是数组？
## 泛型是什么 以及泛型的应用

多个代码对 【不同数据类型】 执行 【相同指令】的情况
泛型：多个类型共享一组代码
泛型允许类型参数化，泛型类型是类型的模板
5种泛型：类、结构、接口、委托、方法
类型占位符 T 来表示泛型

泛型类不是实际的类，而是类的模板
从泛型类型创建实例
声明泛型类型》通过提供【真实类型】创建构造函数类型》从构造类型创建实例
类<T1,T2> 泛型类型参数

性能：泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高
安全：通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。

抑制代码爆炸





##  使用List的区别

list=new list（）会导致每增加一个内容就增加新内存，导致原内存浪费，GC频繁
需要添加一个固定参数，只开辟一个内存，list = new list（50）
性能优化的点

## 请简述ArrayList和 List的主要区别

- ArrayList 不带泛型 数据类型丢失
- List 带泛型 数据类型不丢失
- ArrayList 需要装箱拆箱

List不需要ArrayList存在不安全类型（ArrayList会把所有插 ⼊其中的数据都当做Object来处理）装箱拆箱的 操作（费时）IList是接⼝，ArrayList是⼀个实现了 该接⼝的类，可以被实例化

List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。

## 字典Dictionary是什么？以及 内部实现原理

泛型集合命名空间using System.Collections.Generic;
任何键都必须是唯一

该类最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。
实现原理
1.哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode
2.Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余
3.解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value

Key值 HashFunc Buckets桶 Entries入口（最小数据结构）
![在这里插入图片描述](E:/Typora_MD/Image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNDA3NTIz,size_16,color_FFFFFF,t_70.png)

Dictionary字典中最小的数据结构体Entry，调用Add(Key,Value)方法添加的元素都会被封装在这样的一个结构体中。

Collection版本控制，字典重要变量version，这个变量，在每一次新增、修改和删除操作时，都会使version++
之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。
这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。

[浅析C# Dictionary实现原理-CSDN博客](https://blog.csdn.net/zhaoguanghui2012/article/details/88105715)

泛型集合命名空间using System.Collections.Generic;
任何键都必须是唯一

该类最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率。

实现原理

1. 哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode
2. Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余
3. 解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value
   

————————————————

**介绍**

Dictionary表示键和值的集合。
Dictionary<object, object>是一个泛型。
他本身有集合的功能有时候可以把它看成数组。
他的结构是这样的：Dictionary<[key], [value]>。
他的特点是存入对象是需要与[key]值一一对应的存入该泛型，任何键都是唯一。
通过某一个一定的[key]去找到对应的值。查找元素的时间复杂度为O(1)。
增删查改时间复杂度

Dictionary字典类是hash表，Add操作是O(1)。
其Containskey方法是O(1)，原因是通过hash来查找元素而不是遍历元素。
ContainsValue方法的时间复杂度是O(N)，原因是内部通过遍历key来查找value，而不是通过hash来查找。
ltem[Key]属性根据key来检索value，其时间复杂度也是O(1)。
基本都是O（1）

**底层实现原理**

Dictionary在构造的时候做了以下几件事：
1.初始化一个桶数组this.buckets = new int[prime]
2.初始化一个this.entries = new Entry<TKey, TValue>[prime]

Bucket和entries的容量都为大于字典容量的一个最小的质数
其中this.buckets主要用来进行Hash碰撞

this.entries用来存储字典的内容，并且标识下一个元素的位置。
————————————————
**详细过程**

1. 哈希表法：将不定长的二进制数据集映射到一个较短的二进制数据集，一个Key通过HashFunc得到HashCode。
2. Hash桶算法：对HashCode进行分段显示，常用方法对HashCode直接取余。
3. 拉链法：分段则会导致key对应的哈希桶相同，拉链法的基本思想就像对冲突的元素，建立一个单链表，头指针存储在对应哈希桶的位置。反之就是通过hash桶对应后，遍历单链表，获取value值。
   ————————————————



## 关于List与字典的遍历与查询效率

List的底层，是一个泛型数组，连续且紧密的顺序存储，一般数据存储在缓存中。而字典是离散（散列）分布，由数组和哈希表共同组成，遍历的时候，会伴有换页的操作，且数组都存储在内存中。而读写速度是：缓存>内存>硬盘。因此List更适合遍历。

字典的查询效率是通过元素的key值进行取余操作，找的对应的哈希桶，判定哈希桶对应的哈希表的头节点是不是该元素，若不是进行next操作，对哈希表进行遍历，这两个过程都是常数级别的操作。所以是O（1）。而List的查询效率是先遍历，找到对应的值，因此是O（n）。所以字典更适合查询。


## List容器的作用和特点

## 100个元素集合分别用list（key每一个元素的字段）和 dictionary（key），查找元素，两者的时间复杂度


## ArrayList和List作为泛型，有存储差别吗

##  想要在for循环中删除List（或者vector，都行）中的元素时，有可能出现什么问题，如何避免？

当删除遍历节点后面的节点时，会导致List.Count进行变化，删除元素后，当根据i++，遍历到删除的节点会发生异常。

处理方法：可以从后往前遍历元素进行操作，即删除在访问的前面。

## 给定一个存放参数的数组，重新排列数组

void SortArray(Array arr){Array.Sort(arr);}

## C#中有哪些常用的容器类，各有什么特点，性能区别？

Stack栈：先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍
Queue队列：先进先出，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较
Queue和Stack主要是用来存储临时信息的

Array数组：需要声明长度，不安全
ArrayList数组列表：动态增加数组，不安全，实现了IList接口（表示可按照索引进行访问的非泛型集合对象），Object数组实现
List列表:底层实现是泛型数组，特性，动态扩容，泛型安全
将泛型数据（对值类型来说就是数据本身，对引用类型来说就是引用）存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变。（注：大小指容量，不是Count）
LinkList链表
1、数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。
2、LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。
3、LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。
C#则List和LinkedList的区别
List是数组列表，LinkedList是双向链表，List读取速度快，时间复杂度是O（1），增删比较麻烦，时间复杂度是O(n).
LinkedList读取时间复杂度是O(n),增删时间复杂度是O（1）

HashTable哈希表（散列表）
概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode
装填因子：α=n/m=0.72 ,存储的数据N和空间大小M
然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。
桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。
1、Key—Value形式存取，无序，类型Object，需要类型转换。
2、Hashtable查询速度快，而添加速度相对慢
3、Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。
Directionary<TKey,TVaule>字典，有序，泛型存储不需要进行类型装换（不需要装箱拆箱），碰撞阈值扩容~
HashSet：一组不包含重复的元素集合【LeetCode算法217存在重复元素】

性能排序：
插入性能： LinkedList > Dictionary > HashTable > List
遍历性能：List > LinkedList > Dictionary > HashTable
删除性能： Dictionary > LinkedList > HashTable > List
小结：
在修改较频繁，且查找和删除也较多时，首选LinkedList,
在主要以删除为主，插入为辅，且查找较少时，首选Dictionary，
在查找频繁，而又无需修改的情况下，则首选List。

```c#
//哈希表结构体
private struct bucket {
   public Object key;//键
    public Object val;//值
    public int hash_col;//哈希码
}
//字典结构体
private struct Entry {
    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1
    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1
    public TKey key;        // 存放元素的键
    public TValue value;    // 存放元素的值
}

private int[] buckets;      // Hash桶
private Entry[] entries;    // Entry数组，存放元素
private int count;          // 当前entries的index位置
private int version;        // 当前版本，防止迭代过程中集合被更改
private int freeList;       // 被删除Entry在entries中的下标index，这个位置是空闲的
private int freeCount;      // 有多少个被删除的Entry，有多少个空闲的位置
private IEqualityComparer<TKey> comparer;   // 比较器
private KeyCollection keys;     // 存放Key的集合
private ValueCollection values;     // 存放Value的集合


```

[C# Stack源码剖析_c#类库源码剖析-CSDN博客](https://blog.csdn.net/exiaojiu/article/details/51363735?ops_request_misc=%7B%22request%5Fid%22%3A%22161555037016780261930764%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=161555037016780261930764&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-51363735.first_rank_v2_pc_rank_v29_10&utm_term=C%23+Stack+底层)

[C# Queue源码剖析_quectl-cm原码详解-CSDN博客](https://blog.csdn.net/exiaojiu/article/details/51296041?ops_request_misc=%7B%22request%5Fid%22%3A%22161555081516780265473673%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=161555081516780265473673&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-51296041.first_rank_v2_pc_rank_v29_10&utm_term=C%23+Queue+底层)

[C#List＜T＞源码详解_c# list 源码-CSDN博客](https://blog.csdn.net/enternalstar/article/details/107890981?ops_request_misc=&request_id=&biz_id=102&utm_term=C# List 底层&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-107890981.first_rank_v2_pc_rank_v29_10)

[C# ArrayList源码剖析_c#arrarlist源码-CSDN博客](https://blog.csdn.net/exiaojiu/article/details/51190926?ops_request_misc=&request_id=&biz_id=102&utm_term=C# ArrayList 底层&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-51190926.first_rank_v2_pc_rank_v29_10)

[浅析C# Dictionary实现原理-CSDN博客](https://blog.csdn.net/zhaoguanghui2012/article/details/88105715)

[C# HashTable深度解析-CSDN博客](https://blog.csdn.net/snakorse/article/details/43956061?ops_request_misc=%7B%22request%5Fid%22%3A%22161561749616780264087334%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=161561749616780264087334&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-43956061.first_rank_v2_pc_rank_v29_10&utm_term=C%23+hashtable+底层)



List，HashTable，Dictionary，Stack，Queue
Stack栈：先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍
Queue队列：先进先出，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较
Queue和Stack主要是用来存储临时信息的
Array数组：需要声明长度，不安全
ArrayList数组列表：动态增加数组，不安全，实现了IList接口（表示可按照索引进行访问的非泛型集合对象），Object数组实现
List列表：底层实现是泛型数组，特性，动态扩容，泛型安全
将泛型数据（对值类型来说就是数据本身，对引用类型来说就是引用）存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变。（注：大小指容量，不是Count）
LinkList链表
1、数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。
2、LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。
3、LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。
HashTable哈希表（散列表）
概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode
装填因子：α=n/m=0.72 ,存储的数据N和空间大小M
然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。
桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。
1、Key—Value形式存取，无序，类型Object，需要类型转换。
2、Hashtable查询速度快，而添加速度相对慢
3、Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。



## C#中常规容器和泛型容器有什么区别，哪种效率高？

常规容器有拆箱和装箱操作，速度慢，消耗性能
泛型容器效率更高



不带泛型的容器需要装箱和拆箱操作速度慢所以泛型容器效率更高数据类型更安全

## 什么是IEnumerable？




# 委托与事件

## C#的委托是什么?有何用处?
<Func> <Action><Predicate>

委托类似于一种安全的指针引用，在使用它时是 当做类来看待而不是一个方法，相当于对一组方 法的列表的引用，可以便捷的使用委托对这个方法集合进行操作。委托是对函数指针的封装。

用处：使用委托使程序员可以将方法引用封装在 委托对象内。然后可以将该委托对象传递给可调 用所引用方法的代码，而不必在编译时知道将调 用哪个方法。与C或C++中的函数指针不同，委托 是面向对象，而且是类型安全的。


## 怎么去调用委托
BeginInvoke 和 EndInvoke

## C#中委托和接口有什么区别？各用在什么场合？

委托delegate：unity事件与委托密切相关，回调机制，减少对象之间数据交互
接口interface：多人协作，完全抽象，类单继承
委托是约束方法的集合
接口是约束类具备的功能集合，解决类单继承问题



接口（interface） 是约束类应该具备的功能集合，约束了类应该具备的功能，使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展，同时又合理解决了类的单继承问题。

C#中的委托 是约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作。

在以下情况中使用接口：

1.无法使用继承的场合
2.完全抽象的场合
3.多人协作的场合

以上等等

在以下情况中使用委托：多用于事件处理中

##  C#中 委托和事件的区别

大致来说，委托是一个类，该类内部维护着一个字段，指向一个方法。事件可以被看作一个委托类型的变量，通过事件注册、取消多个委托或方法。

委托可以用“=”来赋值，事件不可以。
委托可以在声明它的类外部进行调用，而事件只能在类的内部进行调用。
委托是一个类型，事件修饰的是一个对象。
委托就是一个类，也可以实例化，通过委托的构造函数来把方法赋值给委托实例
触发委托有2种方式: 委托实例.Invoke(参数列表)，委托实例(参数列表)
事件可以看作是一个委托类型的变量
通过+=为事件注册多个委托实例或多个方法
通过-=为事件注销多个委托实例或多个方法
EventHandler就是一个委托

## C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?

Lambda表达式（任意参数）=> { 表达式} ； => 读作goesto
（a,b）=> { } ;

`````c#
(a,b) => {};
`````

## 概述c#中代理和事件？

代理就是⽤来定义指向⽅法的引⽤。
C＃事件本质就是对消息的封装，⽤作对象之间的通信；发送⽅叫事件发送器，接收⽅叫事件接收器；

## 什么是 Func 和 lambda 表达式？

## 有无event关键字修饰的delegate有什么区别
## 委托赋值的是实例方法和静态方法的区别，得到的委托有什么区别


# 字符串问题
## unicode 和 utf-8 有什么区别？
## string str = “ ” 和 string str = null 有什么区别？

## string和stringbuilder和stringBuffer区别

String是字符串常量。StringBuilder是字符串变量，线程不安全。

String类型是个不可变的对象，当每次对String进⾏改变时都需要⽣成⼀个新的String对象，然后将指针指向⼀个新的对象，如果在⼀个循环⾥⾯，不断的改变⼀个对象，就要不断的⽣成新的对象，所以效率很低，建议在不断更改String对象的地⽅不要使⽤String类型。

StringBuilder对象在做字符串连接操作时是在原来的字符串上进⾏修改，改善了性能。这⼀点我们平时使⽤中也许都知道，连接操作频繁的时候，使⽤StringBuilder对象。
————————————————

String不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。
string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大。

StringBuilder是字符串可变对象。
StringBuilder是非线程安全，所以性能略好，一般用于单线程。

性能比较 StringBuilder>String

1. 如果要操作少量的数据 =string
2. 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder
   ————————————————

String不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。
string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大

StringBuffer是字符串可变对象，可通过自带的StringBuffer.方法来改变并生成想要的字符串。对原实例对象做拼接的实例，不会生成新的实例对象。
拼接使用StringBuilder和StringBuffer，只开辟一个内存空间，这是性能优化的点。

StringBuilder是字符串可变对象，基本和StringBuilder相同。
唯一的区别是StringBuffer是线程安全，相关方法前带synchronized关键字，一般用于多线程
StringBuilder是非线程安全，所以性能略好，一般用于单线程
三者性能比较 StringBuilder>StringBuffer>String

相关方法
StringBuilder.Append 将信息追加到当前 StringBuilder 的结尾。
StringBuilder.AppendFormat 用带格式文本替换字符串中传递的格式说明符。
StringBuilder.Insert 将字符串或对象插入到当前 StringBuilder 对象的指定索引处。
StringBuilder.Remove 从当前 StringBuilder 对象中移除指定数量的字符。
StringBuilder.Replace 替换指定索引处的指定字符。

## C# String 类型比 stringBuilder 类型的优势是什么?

string功能性更强，通用性更好，用途更广泛
string不可变性，线程栈同步
编译器已将把string，并通过操作优化成stringbuilder，在性能上不差，一般可以用string代替stringbuilder



如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而 stringBuilder 是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用stringBuilder这样比较节约内存。但是 string 类的方法和功能仍然还是比 stringBuilder 类要强。

string类由于具有不可变性（即对一个 string 对象进行任何更改时，其实都是创建另外一个 string 类的对象），所以当需要频繁的对一个 string 类对象进行更改的时候，建议使用StringBuilder 类，StringBuilder 类的原理是首先在内存中开辟一定大小的内存空间，当对此 StringBuilder 类对象进行更改时， 如果内存空间大小不够， 会对此内存空间进行扩充，而不是重新创建一个对象，这样如果对一个字符串对象进行频繁操作的时候，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。

String主要用于公共 API，通用性好、用途广泛、读取性能高、占用内存小。

StringBuilder主要用于拼接 String，修改性能好。

不过现在的编译器已经把String的 + 操作优化成 StringBuilder 了， 所以一般用String 就可以了

String是不可变的，所以天然线程同步。

StringBuilder可变，非线程同步。


## 函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。

使用stringbuilder的append

通过StringBuilder那进行append，这样可以减少内存垃圾

## 字符串比较

先用string 变量存储 obj.name ,这用只有一个内存空间保存
如果不存储 obj.name每一次比较都会产生新的内存空间、
比较obj.tag==”Tag“不使用，而是使用避免GC的obj.CompareTag(“tag”)
射线检测SphereColliderNoAlloc可以避免GC，比直接使用SphereCollider性能要好

## 为什么字符串的行为类似于值类型，即使它是引用类型？
## 字符串拼接为什么要用stringbuilder
## abc将c替换d，abcd会产生哪些字符串

# GC问题

[unity的GC优化，原理及方式_unitygc原理-CSDN博客](https://blog.csdn.net/qq_35957011/article/details/84103734)

##  简述GC垃圾管理器（概念）

GC垃圾回收机制，避免堆内存溢出，定期回收那些**没有有效引用**的对象内存
GC优化，就是优化堆内存，减少堆内存，即时回收堆内存
GC归属于CLR



1. C#内部有两个内存管理池:堆内存和栈内存。栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。C#中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。
2. 只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。
3. 一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。
4. 垃圾回收主要是指堆上的内存分配和回收，C#中会定时对堆内存进行GC操作。

## GC产生的原因 （GC会带来的问题、GC触发时机）

**GC会带来的问题**

游戏性能：GC操作是一个极其耗费事件的操作，堆内存上的变量或者引用越多则导致遍历检查时的操作变得十分缓慢，使得游戏运行缓慢，例如当CPU处于游戏性能的关键时刻，任何一个操作就会导致游戏帧率下降，造成极大的影响。

游戏内存：（unityGC采用的是非分代非压缩的标记清除算法）GC操作会产生“内存碎片化”。当一个单元内存从堆中分配出来，其大小取决于存储变量的大小。当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元。（就是说总容量大小时固定的，但是单元内存较小。例如房子很大，房间很小，找不到合适的房间）即下次分配时找不到合适的储存单元，就会触发GC操作，或者堆内存扩容操作，导致GC频发发生和游戏内存越来越大。

**GC触发时机**

1. 在堆内存上进行内存分配操作，而内存不够的时候都会触发垃圾回收来利用闲置的内存;
2. GC会自动的触发，不同平台运行频率不—样;
3. GC可以被强制执行。

## 如何避免GC

1.减少new的次数
2.字符串拼接使用stringbuilder，字符串比较先定义一个变量存储，防止产生无效内存
3.list，new时候，规定内存大小
4.如果要射线检测，应该使用避免GC的方法XXXXNoAlloc函数
5.foreach迭代器容易导致GC（目前Unity5.5已修复），使用For循环
6.使用静态变量，GC不会回收存在的对象，但静态变量的引用对象可能被回收
7.使用枚举替代字符串变量
8.调用gameobject.tag=="XXX"就会产生内存垃圾；那么采用GameObject.CompareTag()可以避免内存垃圾的产生：
9.不要在频繁调用的函数中反复进行堆内存分配，比如OnTriggerXXX，Update等函数
10.在Update函数中，运行有规律的但不需要每一帧执行的代码，可以使用计时器，比如1秒执行一次某些代码！！！



1. 减少临时变量的使用，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）
2. 减少new对象的次数。
3. 对于大量字符串拼接时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）
4. 使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，减少扩容的操作。（扩容后，旧的容器直接抛弃等待GC）
5. 代码逻辑优化：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC。
6. 利用对象池：对象池是一种Unity经常用到的内存管理服务，针对经常消失生成的对象，例如子弹，怪物等，作用在于减少创建每个对象的系统开销。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。
7. 减少装箱拆箱( 装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程)的操作
8. 协程： yeild return 0 会产生装箱拆箱，可以替换为 yeild return null。

## GC垃圾收集器如何决定哪些对象可以从内存中删除？

# 遍历问题

## 能用foreach遍历访问的对象需要实现_ ____接⼝或声明___⽅法的类型（C#遍历）

IEnumerable；GetEnumerator

List和Dictionary类型可以用foreach遍历，他们都实现了IEnumerable接口，申明了GetEnumerator方法。

![在这里插入图片描述](E:/Typora_MD/Image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5ZGG5ZGG5pWy5Luj56CB55qE5bCPWQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png)



## foreach迭代器遍历和for循环遍历的区别

因为foreach是只读的。不能⼀边遍历⼀边修改。

如果集合需要foreach遍历，是否可行，存在一定问题
foreach中的迭代变量item是的只读，不能对其进行修改，比如list.Remove（item）操作
foreach只读的时候记录下来，在对记录做操作，或者直接用for循环遍历
foreach对int[]数组循环已经不产生GC，避免对ArrayList进行遍历

for语句中初始化变量i的作用域，循环体内部可见。
通过索引进行遍历，可以根据索引对所遍历集合进行修改
unity中for循环使用lambda表达式注意闭包问题

**Foreach遍历原理**
任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了 IEnumerator接口的对象。
这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象。
通过这个实现了 IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象
对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素。

```C#
    List<string> list = new List<string>() { "25", "哈3", "26", "花朵" };
	IEnumerator listEnumerator = list.GetEnumerator();
    while (listEnumerator.MoveNext())
    {
        Console.WriteLine(listEnumerator.Current);
    }
```

枚举器的实现（枚举器可用于读取集合中的数据，但不能用于修改集合）

[【Unity优化】Unity中究竟能不能使用foreach？-CSDN博客](https://blog.csdn.net/diudiu5201/article/details/60772002)

### foreach遍历原理

## For，foreach，Enumerator.MoveNext的使用，与内存消耗情况

for通过索引或下标一次进行遍历
foreach和Enumerator.MoveNext通过迭代进行遍历
内存消耗本质没有多少区别
迭代器有一个状态机
before
running：yield return 或 yield break 或迭代结束
after



for循环可以通过索引依次进行遍历，foreach和Enumerator.MoveNext通过迭代的方式进行遍历。
内存消耗上本质上并没有太大的区别。
但是在Unity中的Update中，一般不推荐使用foreach 因为会遗留内存垃圾。

## Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…Catch捕捉异常，发送信息不可行)

foreach迭代器不能进行操作
在循环中记录索引值或者key值，在迭代结束后，查找到这个元素，在进行删除操作

# 设计模式

[常用设计模式有哪些？ (refactoringguru.cn)](https://refactoringguru.cn/design-patterns)

## 什么是单例设计模式？
## 什么是“spaghetti code”意大利面条代码？
## 什么是观察者设计模式Observer design pattern？


## 什么是Builder设计模式？
## 什么是Adapter设计模式？
## 什么是 Bridge 设计模式
## 什么是工厂方法设计模式？
## 什么是策略设计模式Strategy design pattern？
## 什么是模板方法设计模式Template Method design pattern？
## 什么是装饰器设计模式Decorator design pattern？

## 什么是依赖注入设计模式Dependency Injection？
## 什么是控制反转 Inversion of Control？

## 什么是“magic number”反模式？
## 什么是“组合优于继承”的原则？
## 什么是DRY原则？

## SOLID原则是什么？



## 什么是里氏替换原则？（C#多态）

派生类（子类）对象可以在程序中代替其基类对象。(**程序中的对象不管出现在什么地方，都应该可以使用其派生类（子类）的对象进行替换，而不影响程序运行的正确性。**)

里氏替换原则(Liskov Substitution Principle LSP)⾯向对象设计的基本原则之⼀。

- 里氏替换原则中说，任何基类可以出现的地⽅，⼦类⼀定可以出现，作⽤⽅便扩展功能能
- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
- 子类中可以增加自己特有的方法。
- 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
- 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
  

## 什么是凝聚力cohesion？
## 什么是耦合coupling？
## 什么是解构？deconstruction
## 什么是模式匹配pattern matching？

## 什么是expression-bodied members表情体成员？
## binary number 二进制数系统如何工作？

## 什么是记录records和记录结构record structs？

# 异常处理
## 错误的三种主要类型是什么？
## 如何在 C# 中处理异常？
## 为什么“catch(Exception)”几乎总是一个坏主意（什么时候不是？）？
## “抛 throw ”和“抛出throw ex”有什么区别？
## 什么是异常？异常有什么用？
## C#中处理异常采用的结构化异常处理语句有哪些？并简要说明？
## 异常机制

# 反射的实现原理？

可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段。

主要使用的类库：System.Reflection



定义：运行时，**动态获取类型信息**,**动态创建对象**,**动态访问成员**的过程。
另一种定义：审查元数据并收集元数据的信息。
元数据：编译后的最基本数据单元，就是一堆表，反射就是解析这些元数据。
反射是在运行期间获取到类、对象、方法、数据的一种手段
主要使用类库System.Reflection
反射要点：如何获取类型，根据类型来动态创建对象，反射获取方法以及动态调用方法，动态创建委托
一、动态获取类型信息
1.System.Reflection.**Assembly**.Load(“XXXX.dll”) 动态加载程序集
2.System.**Type**.GetType(“XXXX类名”); //动态获取某程序集中某类信息
3.obj.GetType(); //已知对象获取类信息 ——或者——typeof(类型) //已知类类型
二、动态创建对象实例（上一步操作后获得类对象）
System.Activator.CreateInstance(Type type);
三、动态访问成员调用方法（上一步操作后已获取实例对象）
System.Reflection.MethodInfo method = type.GetMethod(“方法名”);//获得方法
System.Reflection.MethodInfo.Invoke(object , new object[]{参数}) //调用的类实例和实例参数

核心类
System.Reflection.Assembly 描述程序集
System.Type 描述类
System.Reflection.FieldInfo 描述了类的字段
System.Reflection.ConstructorInfo 描述构造函数
System.Reflection.MethodInfo 描述类的方法
System.Reflection.PropertyInfo 描述类的属性

通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。

审查元数据并收集关于它的类型信息的能⼒。

```c#
实现步骤：
1. 导⼊using System.Reflection;
2. Assembly.Load("程序集")加载程序集,返回类型是
⼀个Assembly
3.  foreach (Type type in assembly.GetTypes())
         {
            string t = type.Name;
         }
得到程序集中所有类的名称
4. Type type = assembly.GetType("程序集.类名");获取
当前类的类型
5. Activator.CreateInstance(type); 创建此类型实例
6. MethodInfo mInfo = type.GetMethod("⽅法名");获取
当前⽅法
7. mInfo.Invoke(null,⽅法参数);
```



反射耗性能，lua是动态语言，一种小巧的脚本语言，会使用反射机制。

知识扩展
手机端不支持编译，需要热更方案，通过lua的反射机制将旧的DLL文件替换成新的DLL文件。
Xlua是lua框架，由TX鹅肠进行维护，方便了C#与lua相互调用，C#端实现lua虚拟机
链接：参考资料太多，主要搜索，C#反射机制，lua，xlua性能等等。

## typeof 和 GetType 有什么区别？

# C#的闭包

# MVC是什么？如何实现 MVC ？
说了一下 MVC 在 Unity 中的应用，不过正经的 MVC 是和数据库挂钩的。

MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。

用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。
　　通常模型对象负责在数据库中存取数据。
View（视图）是应用程序中处理数据显示的部分。
　　通常视图是依据模型数据创建的。
Controller（控制器）是应用程序中处理用户交互的部分。
　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据



# .Net 与 Mono 的关系？

mono是.net的一个开源跨平台工具，就类似java虚拟机，java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。
.net只能在windows下运行，mono可以实现跨平台编译运行，可以运行于Linux，Unix，Mac OS等。

.Net是一个语言平台
Mono为.Net提供集成开发环境，集成并实现了
.NET的编译器、CLR 和基础类库，
使得.Net既可以运行在windows也可以运行于 linux，Unix，Mac OS 等。

#  C# 和 .NET 有什么区别？

#  C#和C++的区别?

C#不支持指针，但可以使用Unsafe，不安全模式，CLR不检测
C#可以定义指针的类型、整数型、实数型、struct结构体
C#指针操作符、C#指针定义
使用fixed，可以操作类中的值类型
相同点：都是地址
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
不同点：
指针是个实体，引用是个别名。
sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
引用是类型安全的，而指针在不安全模式下



简单的说:C# 与C++ 比较的话，最重要的特性 就是C# 是一种完全面向对象的语言，而C++ 不 是，另外C# 是基于IL 中间语言
和.NET Framework CLR 的，在可移植性，可维 护性和强壮性都比C++ 有很大的改进。C# 的设 计目标是用来开发快速稳定可扩展的应用程序， 当然也可以通过Interop和Pinvoke 完成一些底层操作



具体对比：

1. 继承：C++支持多继承，C#类只能继承一个基类中的实现但可以实现多个接口。
2. 数组：声明 C# 数组和声明 C++ 数组的语法不同。在 C# 中，“[]”标记出现在数组类型的后面。
3. 数据类型：在C++中bool类可以与整型转换，但C#中bool 类型和其他类型（特别是 int）之间没有转换。long 类型：
4. 在 C# 中，long 数据类型为 64 位，而在 C++ 中为 32 位。
5. struct 类型：在 C# 中，类和结构在语义上不同。struct 是值类型，而 class 是引用类型。
6. switch 语句：与 C++ 中的 switch 语句不同，C# 不支持从一个 case 标签贯穿到另一个 case 标签。
7. delegate 类型：委托与 C++ 中的函数指针基本相似，但前者具有类型安全，是安全的。
8. 从派生类调用重写基类成员。 base
9. 使用 new 修饰符显式隐藏继承成员。
10. 重写方法需要父类方法中用virtual声名，子类方法用override 关键字。
11. 预处理器指令用于条件编译。C# 中不使用头文件。 C# 预处理器指令
12. 异常处理：C#中引入了 finally 语句，这是C++没有的。
13. C# 运算符：C# 支持其他运算符，如 is 和 typeof。它还引入了某些逻辑运算符的不同功能。
14. static 的使用，static方法只能由类名调用，改变static变量。
15. 在构造基类上替代 C++ 初始化列表的方法。
16. Main 方法和 C++ 及Java中的 main 函数的声明方式不同，Main而不能用main
17. 方法参数：C# 支持 ref 和 out 参数，这两个参数取代指针通过引用传递参数。
18. 在 C# 中只能在unsafe不安全模式下才使用指针。
19. 在 C# 中以不同的方式执行重载运算符。
20. 字符串：C# 字符串不同于 C++ 字符串。
21. foreach:C#從VB中引入了foreach关键字使得以循环访问数组和集合。
22. C# 中没有全局方法和全局变量：方法和变量必须包含在类型声明（如 class 或 struct）中。
23. C# 中没有头文件和 #include 指令：using 指令用于引用其他未完全限定类型名的命名空间中的类型。
24. C# 中的局部变量在初始化前不能使用。
25. 析构函数：在 C# 中，不能控制析构函数的调用时间，原因是析构函数由垃圾回收器自动调用。 析构函数
26. 构造函数：与 C++ 类似，如果在 C# 中没有提供类构造函数，则为您自动生成默认构造函数。该默认构造函数将所有
27. 字段初始化为它们的默认值。
28. 在 C# 中，方法参数不能有默认值。如果要获得同样的效果，需使用方法重载。
    

# C#引用和C++指针的区别 

1. 引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。
2. 引用必须初始化，指定对哪个对象的引用，指针不需要。
3. 引用初始化后不能改变，指针可以改变所指对象的值。
4. 引用访问对象是直接访问，指针访问对象是间接访问。
5. 引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。
6. 引用没有const，指针有const
7. 引用和指针的+自增运算符意义不同。
8. 引用不需要分配内存空间，指针需要。

C#不支持指针，但可以使用Unsafe，不安全模式，CLR不检测
C#可以定义指针的类型、整数型、实数型、struct结构体
C#指针操作符、C#指针定义
使用fixed，可以操作类中的值类型
相同点：都是地址
指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。

不同点：

指针是个实体，引用是个别名。
sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
引用是类型安全的，而指针在不安全模式下
引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。
引用必须初始化，指定对哪个对象的引用，指针不需要。
引用初始化后不能改变，指针可以改变所指对象的值。
引用访问对象是直接访问，指针访问对象是间接访问。
引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。
引用没有const，指针有const
引用和指针的+自增运算符意义不同。
引用不需要分配内存空间，指针需要。

# C#如何和java/oc/c++交互


# 什么是公共中间语言 （CIL）？

# 什么是公共语言运行时 （CLR）？


# 什么是预处理器指令？



# 当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？ 

Unity对象池
设计单例模式全局实例化一次



设计单例模式进行创建对象或者使用对象池

# GameObject a=new GameObject() GameObject b=a 实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？

存在
a引用地址在线程栈中，数据内容在托管堆中
b引用地址在线程栈中，数据内容指向A的托管堆中的内容
B删除，只是删除b的引用地址

#  C# 资源分配
# 同步和异步
同步是进程执行完，下一步
异步是不等下一个，就进行下一步
# 内存一般分为什么区域？

# JIT和AOT区别

Just-In-Time -实时编译

执行慢安装快占空间小一点

Ahead-Of-Time -预先编译

执行快安装慢占内存占外存大

# 什么是模拟mocks?
# 什么是 NuGet 包？
# 调试版本和发布版本有什么区别？
# 什么是indexers索引器？
# 什么是缓存caching?？


# 数据库优化方法：
杀 dba ，遵循第三范式，建立适当索引
说一下数据库特性也好：原子性，一致性，隔离性，持久性。

# 有一头母猪，它每年年初生一头小母猪。每头小母猪从第4个年头开始，每年年初也生一头小母 猪。请编程实现在第n年的时候，共有多少头母猪？