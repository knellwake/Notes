
# **Done is better than perfect.**



功能高内聚，模块低耦合。
# 基础
强类型语言 C# => dynamic 动态类型
弱类型语言 -> 不受数据类型约束

```C#
int? x = null;
int y = x ?? 0;
// ?? 操作符 -> 表示当x为空时输出后面的数值（0）
cw.(y); // 0
```

三元运算符  ？:
```C#
string str = (x >= 60) ? "及格" : "不及格";
```

- ref 引用参数
- out 输出参数
- params 数组参数
- this 参数 扩展方法 -> LinQ
## 变量
用途：存储数据。
<font color="#2DC26B"><font color="#2DC26B">变量名表示（对应着）变量的值在内存中存储位置，并且每个变量都有一个类型，以决定什么样的</font>值能够存入变量。</font>
- 广义变量 ：静态变量、实例变量、数组元素、值参数、引用参数、输出参数、局部变量
- 狭义变量 ： 局部变量
**变量：** 以变量名所对应的内存地址为起点，以其数据类型所要求的存储空间为长度的一块内存区域。
**常量** ：不可再赋值，必初始化；
## 装箱与拆箱
**装箱 ：**  值类型 赋值转换为 引用类型；（值类型数据从栈copy到堆，引用类型地址从栈指向堆空间数据）
**拆箱：** 引用类型 转换为 值类型；（堆空间的数据 copy 到栈空间）
*会损失性能*

## 值类型与引用类型

[C#详解值类型和引用类型区别_c# 引用类型-CSDN博客](https://blog.csdn.net/qiaoquan3/article/details/51202926)

## 五大数据类型
- 类
- 接口
- 委托
- 结构体
- 枚举

![image-20231020163218349](E:/Typora_MD/Image/image-20231020163218349.png)
<font color="#00b050">内建类型，而不属于基本类型</font>

- 中文得用string 类型 
- objec 对象类型 
- dynamic 动态类型 
## 类三大成员
- 属性
- 方法
- 事件
<span style="background:#fff88f">程序 = 数据 + 算法</span>
# 委托
## 什么是委托 

委托（delegate）是函数指针的“升级版”；
是一种类（Class），类是一种数据类型，所以委托也是。
强类型委托：
- Action
- Func
- Predicate
## 委托有什么用？
1. 将函数作为函数参数进行传递
2. 声明事件并注册

自定义委托：所封装的方法需要“类型兼容”；
- 返回值的数据类型一致；
- 参数列表个数和数据类型一致（参数名不需要一样）；

![image-20231020163209508](E:/Typora_MD/Image/image-20231020163209508.png)
## 委托的一般使用
###  实例：把方法当作参数传给另一个方法
1. <font color="#00b050">模板方法</font>，“借用”指定的外部方法来产生结果
	- 委托有返回值
	- 提高代码的重复使用
2.  <font color="#00b050">回调（callback）方法</font>，调用指定的外部方法
	- 委托无返回值
## 事件
希望一个类的某些成员在发生变化时能被外界观测到；
推荐命名规范 ：名词+动词（被动）

# 面向对象
![image-20231020163201362](E:/Typora_MD/Image/image-20231020163201362.png)
每个<font color="#00b050">对象</font>都是某个<font color="#00b050">类</font>（class)的一个<font color="#00b050">实例</font>；——《Thinking in Java》

OOP设计法则：复合优于继承
[认识 UML 类关系——依赖、关联、聚合、组合、泛化_依赖关系_恋喵大鲤鱼的博客-CSDN博客](https://blog.csdn.net/K346K346/article/details/59582926)
## 封装（encapsulate）
对业务逻辑实现细节的隐藏；
## 继承
<font color="#00b050">好处：</font>
- 省去绝大部分重复性代码，提高代码的复用性。
- 多态 ： 继承对象的某一个行为却具有多个不同的表现形式的能力。

实例构造器是不能被继承的。
this.
base.（只能访问上一层）


## 多态
调用同一个类，执行不同的方法；

调到与 new xx; 实例对象相关。
父 x = new 子；
父类声明指向子类实例。
调到子类最新版本。

## 抽象类 abstract
有别于虚方法，安全判定
抽象方法一定在抽象类中；
抽象类中，可以由抽象方法和普通方法；

## 接口
接口为解耦而生： “高内聚，低耦合”，方便单元测试；

## 复合
- 描述两个class之间的关系
- has-a 有一个...东西(如，公交车有一个引擎)
- 不同类之间的包含与被包含的关系
复合灵活性高，依赖注入...


## 如何实现低耦合？
- 封装
- 类的关联性 
	- 依赖、关联、聚合、组合、泛化等等
- 使用接口
	- 解决耦合的基本思路

## 结构体
![image-20231020163125909](E:/Typora_MD/Image/image-20231020163125909.png)

![image-20231020163133996](E:/Typora_MD/Image/image-20231020163133996.png)

## Class
![image-20231020163140263](E:/Typora_MD/Image/image-20231020163140263.png)



# SOLID

## 单一责任原则 Single Responsibility Principle

> 一个类应该只负责一件事。

["单一责任"](02_NamesAfterRefactorToSRP)

# 多态
变量 父类 = new 子类();

调用的是 变量后的父类方法

![img.png](E:\Typora_MD\img\img.png)

1. 判断父调用的方法是否是 Virtual 方法
   > * 是 Virtual 方法  
   > 
    > 并且子类进行了重写override 那么 调用出来的就是子类方法 
   > 
   > 子类没有重写 那么 调用的就还是父类方法内容
   > 
> * 否 不是Virtual  --》
> 
> 先判断父类是否有这个方法 ：
> 
> 没有 即编译时报错 找不到方法
> 
> 有 就执行父类里面的方法内容 ，总之 不会去执行子类独有方法 而父类没有的方法

“组合优于继承”

# 继承与构造函数
子类对象 会优先执行 父类构造 （默认会有无参构造）

当 父类添加 有参构造 时候 默认的无参构造 会被覆盖 

子类需要 :base 继承父类有参构造的参数 or 父类自建一个无参构造

# 抽象方法 与 虚方法
![img1.png](E:\Typora_MD\img\img1.png)

![img2.png](E:\Typora_MD\img\img2.png)

# 接口 与 抽象类
![img3.png](E:\Typora_MD\img\img3.png)

![img4.png](E:\Typora_MD\img\img4.png)

![img5.png](E:\Typora_MD\img\img5.png)

# 继承 与 接口 所构造的关系
![img_1.png](E:\Typora_MD\img\img_1.png)
