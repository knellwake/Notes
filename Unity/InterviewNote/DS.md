# 数据结构与算法基础

## 冒泡排序

### 冒泡排序怎么做？时间复杂度？



## 选择排序

## 二分查找

## 栈 堆 队列

##### Heap与Stack有何区别?

1. heap是堆，stack是栈。
2. stack的空间由操作系统自 动分配和释放，heap的空间是手动申请和释放的， heap常用new关键字来分配。
3. stack空间有限，heap 的空间是很大的自由区。

##### 栈溢出一般是由什么原因导致

1. 无限递归。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
2. 无限循环。
3. 大量局部变量分配。

### Stack栈和Queue队列

相同点：

1. 都是线性结构。
2. 插入操作都是限定在表尾进行。
3. 都可以通过顺序结构和链式结构实现。
4. 插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。
5. 多链栈和多链队列的管理模式可以相同。
6. 底层都是由泛型数组实现。

不同点：

1. 栈先进后出，队列先进先出：删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。
2. 顺序栈能够实现多栈空间共享，而顺序队列不能。
3. 应用场景不同

常见栈的应用场景包括

1. 括号问题的求解，
2. 深度优先搜索遍历等；
3. 函数调用和递归实现，
4. 表达式的转换和求值

常见的队列的应用场景包括

1. 计算机系统中各种资源的管理，
2. 消息缓冲器的管理
3. 广度优先搜索遍历等

### 用栈实现队列 、 用队列实现栈
###　堆栈实现队列

## 二叉树
### 二叉树是怎么样的？如果将每一个叶子节点输出？具体算法如何实现？

## 链表
### 单双向链表的区别：

- 指向不同：单向链表只有一个指向下一结点的指针，双向链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针。
- 功能不同：单向链表只能next ，双向链表可以return。
- 单双向不同：单链表只能单向读取，双向链表可以双向遍历。

### 单向链表优缺点：

优点：单向链表增加删除节点简单。遍历时候不会死循环；
缺点：只能从头到尾遍历。只能找到后继，无法找到前驱，也就是只能前进。

###　双向链表优缺点：

优点：可以找到前驱和后继，可进可退；
缺点：增加删除节点复杂，多需要分配一个指针存储空间.

链表与数组的对比

1. 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；数组可以根据下标直接存取，时间复杂度O(1)。

2. 链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项，非常繁琐）链表必须根据next指针找到下一个元素。

   

   如果需要快速访问数据，很少或不插入和删除元素，就应该用数组；相反，如果需要经常插入和删除元素就需要用链表数据结构了。



### 单链表翻转，adcde，转换成 edcba , 怎么做

### 单链表，输出倒数第2个，奇数个节点输出数据，节点倒序？
### 链表与数组的对比　

## 哈希表
### 哈希表与字典对比

字典：内部用了Hashtable作为存储结构

如果我们试图找到一个不存在的键，它将返回 / 抛出异常。
它比哈希表更快，因为没有装箱和拆箱，尤其是值类型。
仅公共静态成员是线程安全的。
字典是一种通用类型，这意味着我们可以将其与任何数据类型一起使用（创建时，必须同时指定键和值的数据类型）。
Dictionay 是 Hashtable 的类型安全实现， Keys和Values是强类型的。
Dictionary遍历输出的顺序，就是加入的顺序

哈希表：

如果我们尝试查找不存在的键，则返回 null。
它比字典慢，因为它需要装箱和拆箱。
哈希表中的所有成员都是线程安全的，
哈希表不是通用类型，
Hashtable 是松散类型的数据结构，我们可以添加任何类型的键和值。
HashTable是经过优化的，访问下标的对象先散列过，所以内部是无序散列的
————————————————

### 哈希表的实现原理
### GetHashCode 方法的用途是什么？
### HashMap和HashTable



##　二叉树相关

计算深度（高度）
二叉树的高度是二叉树结点层次的最大值，也就是其左右子树的最大高度+1。当树为空时，高度为0；否则为其左右子树最大高度+1。

遍历:（看根节点的位置）

前序遍历：（根左右）先访问根节点，再访问左节点，再访问右节点。
中序遍历：（左根右）先访问左节点，再访问根节点，再访问右节点。
后序遍历：（左右根）先访问左节点，再访问右节点，再访问根节点。




# Unity 游戏常用算法
## 寻路算法：A* 算法
## Unity游戏常用洗牌算法

