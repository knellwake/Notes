

# 判断与循环

## 回文数 *

**思路**
整体数字 拆解 成单个
存储 转换顺序后的 单个 数字 并且合体
合体后的数字 与 原数字 相比较判断

**解题方法**
两个临时变量 存储 原数字 / 合体数字
while 循环 取余 取单个数字 存储到合体数字
每次循环截取最后一位数（也就是已经被取余的数字） 直到为0 取完

**注意**
需要注意 原数字 要 先存储
避免 原数字已经操作完毕 变成 0
和0 比较永远为FALSE

> [9. 回文数 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-number/solutions/2553209/hui-wen-shu-shu-xue-jie-ti-guo-cheng-ji-i5np8/)

```java
class Solution {
    public boolean isPalindrome(int x) {
        int cur = 0;
        int digit = x;

        if(x < 0)
            return false;

        while (digit != 0) {
            cur = cur * 10 + digit % 10;
            digit /= 10;
        }
        return cur == x;
    }
}
```

```JAVA
    public static boolean isPalindromicNumber(int num) {
        int digit = num;
        int cur = 0;
        while (digit > 0) {
            cur = cur * 10 + digit % 10;
            digit /= 10;
        }
        return cur == num;
    }
}
```

## 计算个人所得税 *

2019年1月1日起，国家推出新的个人所得税政策，起征点上调值5000元。也就是说税前工资扣除三险一金（三险一金数额假设是税前工资的10%）后如果不足5000元，则不交税。如果大于5000元，那么大于5000元的部分按梯度交税，具体梯度比例如下：

​	0 ~ 3000元的部分，交税3%			

​	3000 ~ 12000元的部分，交税10%

​	12000 ~ 25000的部分 ， 交税20%		

​	25000 ~ 35000的部分，交税25%

​	35000 ~ 55000的部分，交税30%		

​	55000 ~ 80000的部分，交税35%

​	超过80000的部分，交税45%

比如：黑马某学员入职一家企业后，税前工资是15000，则他每月该交个税的部分是15000-1500-5000=8500元，个税缴纳数额是3000×3%+5500×10%=640元。税后工资12860元。

请完成一个个税计算程序，在用户输入税前工资后，计算出他对应的纳税数额，以及税后工资为多少？

**解题思路**

1. 使用多条件的if...else对应各个纳税梯度，分别计算每一个梯度的纳税数额。

**操作步骤**

1. 提示用户输入税前工资，使用键盘录入让用户输入一个整数。
2. 计算工资中应交税部分。也就是去除三险一金和起征点数额。
3. 使用多条件if..else..对每个区间分别判断，用每个梯度的计算公式求出对应的纳税数额。
4. 根据求出的纳税数额求出税后工资。

```java
    public static void calculateSalary() {
        Scanner sc = new Scanner(System.in);
        double salary = sc.nextDouble();//工资
        int cutoffPoint = 5000;//个税起征点

        double payTax = salary - (salary * 0.1) - cutoffPoint;//应付税款部分

        double donePay = 0;//个税缴纳数额
        if (salary > cutoffPoint) {
            //	0 ~ 3000元的部分，交税3%
            if (payTax > 0 && payTax <= 3000) {
                donePay = payTax * 0.03;

                //3000 ~ 12000元的部分，交税10%
            } else if (payTax > 3000 && payTax <= 12000) {
                donePay = (payTax - 3000) * 0.1 + (3000 * 0.03);

                //	12000 ~ 25000的部分 ， 交税20%
            } else if (payTax > 12000 && payTax <= 25000) {
                donePay = (payTax - 12000) * 0.2 + (9000 * 0.1) + (3000 * 0.03);

                //	25000 ~ 35000的部分，交税25%
            } else if (payTax > 25000 && payTax <= 35000) {
                donePay = (payTax - 25000) * 0.25 + (13000 * 0.2) + (9000 * 0.1) + (3000 * 0.03);

                //	35000 ~ 55000的部分，交税30%
            } else if (payTax > 35000 && payTax <= 55000) {
                donePay = (payTax - 35000) * 0.3 + (10000 * 0.25) + (13000 * 0.2) + (9000 * 0.1) + (3000 * 0.03);

                //55000 ~ 80000的部分，交税35%
            } else if (payTax > 55000 && payTax <= 80000) {
                donePay = (payTax - 55000) * 0.35 + (20000 * 0.3) + (10000 * 0.25) + (13000 * 0.2) + (9000 * 0.1) + (3000 * 0.03);

                //超过80000的部分，交税45%
            } else if (payTax > 80000) {
                donePay = (payTax - 80000) * 0.45 + (25000 * 0.35) + (20000 * 0.3) + (10000 * 0.25) + (13000 * 0.2) + (9000 * 0.1) + (3000 * 0.03);
            }
        }
        System.out.println("个税缴纳数额: " + donePay);
   System.out.println("薪资等于: 薪资 减去 三险一金 和 扣税部分："+(salary - (salary *0.1) - donePay));
    }
```

## 计算年份 *

已知2019年是猪年，请在控制台输出从1949年到2019年中所有是猪年的年份。

**解题思路**

1. 使用for循环逐年判断，根据2019是猪年这个条件，使用if来判断其他是猪年的年份。

 **操作步骤**

1. 定义for循环，1949到2019的年份是循环次数。
2. 对每个年份逐个判断，如果年份和2019的差值是12的倍数，说明这年是猪年
3. 打印符合条件的年份

```java
    for (int i = 1949; i <= 2019; i++) {
        if ((2019 - i ) % 12 == 0)
            System.out.println(i);
    }
```

## 逢七过 *

游戏规则：从任意一个数字开始报数，当你要报的数字是包含7或者是7的倍数时都要说过：过

使用程序在控制台打印出1-100之间的满足逢七必过规则的数据 

举例：1 2 3 4 5 6 过 8 9 10 11 12 13 过 15 16 过 18 ...

`````java
    public static void meetSevenPass() {
        for (int i = 1; i <= 100; i++) {
            int ge = i % 10;
            int shi = i / 10 % 10;
            if (i % 7 == 0 || ge == 7 || shi == 7) {
                System.out.println("过");
                continue;
            }

            System.out.println(i);
        }
    }
`````

## 判断是否为质数 *

键盘录入一个正整数 x ，判断该整数是否为一个质数。 

质数：
7 = 1 * 7 质数
8 = 1 * 8  2 * 4 合数

质数 ：只能被1和本身整除

**解题思路**

 1 和它本身 被循环排除在外，只能是在内被整除了 就说明不是质数，直接break结束循环

```java
//分析：
//1.键盘录入一个正整数
//number
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个正整数");
int number = sc.nextInt();//9

//定义一个变量，表示标记
//标记着number是否为一个质数
//true： 是一个质数
//false : 不是一个质数

//表示最初就认为number是一个质数
boolean flag = true;

//2.判断
//写一个循环，从2开始判断，一直判断到number-1为止
//看这个范围之内，有没有数字可以被number整除
for (int i = 2; i < number; i++) {
    //i 依次表示这个范围之内的每一个数字
    //看number是否能被i整除就可以了
    if(number % i == 0){// 9 % 2 = 1
        flag = false;
        break;
    }
}

if(flag){
    System.out.println(number + "是一个质数");
}else{
    System.out.println(number + "不是一个质数");
}
```

```java
public static boolean isPrimeNumber(int num) {
    boolean isFlag = true;
    for (int i = 2; i < num; i++) {
        if (num % i == 0) {
            isFlag = false;
            break;
        }
    }
    return isFlag;
}
```

# 数组

## 打乱数据 *

定义一个数组，存入1~5。要求打乱数组中所有数据的顺序。

方法一： 在当前数组中打乱顺序

方法二：新建数组 把 旧数组值随机存放入 新数组 不重复

```java
public static void main(String[] args) {
    Random ran = new Random();
    int[] arr = {1, 2, 3, 4, 5};
    for (int i = 0; i < arr.length; i++) {
       
        int ranNum = ran.nextInt(arr.length);
        
        int temp = arr[i];
        arr[i] = arr[ranNum];
        arr[ranNum] = temp;
    }

    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i]);
        if(i < arr.length-1)
            System.out.print(",");
    }
}
```

## 找最小值 *

现有一个小数数组{12.9, 53.54, 75.0, 99.1, 3.14}。请编写代码，找出数组中的最小值并打印。

**解题思路**

将数组的第一个值作为参考值，遍历数组，依次比较，记录更小值。

```java
    public static void main(String[] args) {
        double[] arr = {12.9, 53.54, 75.0, 99.1, 3.14};

        double min = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if(min > arr[i])
                min = arr[i];
        }
        System.out.println(min);
    }
```

## 随机数存入数组 并 求和 *

创建一个长度为6的整数数组。

随机生成六个0（包含）-100（不包含）之间的整数存放到数组中，然后计算出数组中所有元素的和并打印。

```java
    public static void main(String[] args) {
        int[] arr = new int[6];
        Random ran = new Random();
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            int ranNum = ran.nextInt(100);
            arr[i] = ranNum;
        }

        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];
            System.out.println(arr[i]);
        }
        System.out.println(sum);
    }
```

## 将数组元素 表示 个位十位百位... 打印出来 *

现有一个整数数组，数组中的每个元素都是[0-9]之间的数字，从数组的最大索引位置开始到最小索引位置，依次表示整数的个位、十位、百位。。。依次类推。请编写程序计算，这个数组所表示的整数值。例如：

```java
数组：{2, 1, 3, 5, 4}
表示的整数为：21354 // 注：是整数类型的两万一千三百五十四，不是字符串拼起来的。
```

**解题思路**

遍历数组，与求和的思路相似，但算法不同，累加时需要将高位*10再累加。

**解法一：**

```java
    public static void main(String[] args) {
        //1.定义数组
        int[] arr = {2, 1, 3, 5, 4};
        //2.定义变量存储最终的整数
        int num = 0;
        //3.对数组进行遍历
        for (int i = 0; i < arr.length; i++) {
            //4.计算，高位乘以10再加上当前位的值
            num = num * 10 + arr[i];
        }
        System.out.println(num);
    }
```

```java
public static void main(String[] args) {
    int[] arr = {2, 1, 3, 5, 4};
    int record = 0;
    for (int i = 0; i < arr.length; i++) {
        record = record * 10 + arr[i];
    }
    System.out.println(record);
}
```

> num = num * 10 + arr[i];
>
> ① 0 * 10 + 2  num = 2
>
> ② 2 * 10 + 1 num = 21
>
> ③ 21 * 10 +3 num = 213
>
> ④ 213 * 10 + 5 num = 2135
>
> ⑤ 2135 * 10 + 4 num = 21354

**解法二：**

`Math.pow(数值,几次幂)`; 数值的几次方

```java
    int[] arr = {2, 1, 3, 5, 4};
    int v = 0;
    for (int i = 0, j = arr.length - 1; i < arr.length; i++, j--) {
        int pow = (int) Math.pow(10, j);
        v += arr[i] * pow;
    }
    System.out.println(v);
```

## 生成新数组 并 插入值 *

有一个数组，其中有十个元素从小到大依次排列 {12,14,23,45,66,68,70,77,90,91}。

再通过键盘录入一个整数数字。

要求：把数字放入数组序列中，生成一个新的数组，并且数组的元素依旧是从小到大排列的。执行效果如下：

```java
请输入一个整数数字：
50
生成的新数组是：12 14 23 45 50 66 68 70 77 90 91
```

**操作步骤**

1. 定义原数组oldArr，和一个比原数组长度大1的新数组newArr。
2. 定义变量index用于记录num存放的索引位置。
3. 遍历数组，小于或等于num的元素直接存放到原来的位置，大于num的元素往后移动一个位置。
4. 存放结束之后，中间会空出一个位置,在遍历时用index记录这个位置。把num放在这个索引处。
5. 最终遍历新数组打印结果。

```JAVA
public static void main(String[] args) {
    int num = 50;
    int[] oldArr = {12, 14, 23, 45, 66, 68, 70, 77, 90, 91};
    int[] newArr = new int[oldArr.length + 1];
    int index = 0;

    for (int i = 0; i < oldArr.length; i++) {
        if (oldArr[i] <= num) {
            newArr[i] = oldArr[i];
            index = i + 1; //在这里存储index
        } else{
            newArr[i + 1] = oldArr[i];
        }
    }
    
    newArr[index] = num;
    
    for (int i = 0; i < newArr.length; i++) {
        System.out.print(newArr[i] + " ");
    }
}
```

```JAVA
public static void main(String[] args) {
    int[] arr = {12, 14, 23, 45, 66, 68, 70, 77, 90, 91};
    int[] arrNew = new int[arr.length + 1];
    int num = 50;
    int index = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] < num) {
            arrNew[i] = arr[i];
            index = i + 1;
        } else {
            arrNew[index] = num;
            arrNew[i + 1] = arr[i];
        }
    }

    for (int i = 0; i < arrNew.length; i++) {
        System.out.println(arrNew[i]);
    }
}
```

## 奇数在左 偶数在右 *

定义一个数组其中包含多个数字。用自己的方式最终实现，奇数放在数组的左边，偶数放在数组的右边。

（可以创建其他数组，不必须在原数组中改变）

**操作步骤**

1. 定义出原数组arr，其中包含多个数字。
2. 定义新数组arrNew，和arr的长度一样。
3. 定义变量left，初始值是0准备从左边放元素；定义变量right，初始值是arr.length-1准备从右边放元素。
4. 对原数组arr进行遍历。
5. 如果元素是奇数，则放在新数组arrNew的左边，left变量加一。
6. 如果元素是偶数，则放在新数组arrNew的右边，right变量减一。
7. 遍历新数组arrNew打印最终结果。

```java
    public static void main(String[] args) {
        int[] arr = {12, 23, 34, 45, 67, 78, 11, 22};
        int[] arrNew = new int[arr.length];

        int right = 0;
        int left = arrNew.length - 1;

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] % 2 != 0) {
                arrNew[right] = arr[i];
                right++;
            } else {
                arrNew[left] = arr[i];
                left--;
            }
        }

        for (int i = 0; i < arrNew.length; i++) {
            System.out.print(arrNew[i]+" ");
        }
    }
```

# 方法

## 数组遍历 *

设计一个方法用于数组遍历，要求遍历的结果是在一行上的。例如：[11, 22, 33, 44, 55] 

```java
public static void main(String[] args) {
    int[] arr = {1, 2, 3, 4, 5};
    getArray(arr);
}
public static void getArray(int[] arr) {
    
    System.out.print("[");
    
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i]);
        
        if (i < arr.length - 1)// 符号
            System.out.print(",");
        else
            System.out.print("]");
    }
}
```

不同写法：

```java
public static void printArr(int[] arr){
    System.out.print("[");
    
    for (int i = 0; i < arr.length; i++) {
        
        if(i == arr.length - 1){ // 符号
            System.out.println(arr[i] + "]");
        }else{
            System.out.print(arr[i] + ", ");
        }
        
    }
}
```

## 复制数组 *

一个数组 复制到另外一个数组 设置区间范围

![image-20231205155121770](https://raw.githubusercontent.com/GavinGroves/Notes/main/img/image-20231205155121770.png)

**分析**

1. Main 定义原始数组
2. 调用方法拷贝数据 --> 创建方法
3. 方法中 定义新数组
4. from - to 拷贝到新数组 注意index区间

```java
    public static void main(String[] args) {
        int[] arr = {12, 45, 98, 73, 60, 22, 11, 7, 5, 2};

        int[] newArr = copyOfRange(arr, 3, 7);
        for (int i = 0; i < newArr.length; i++) {
            System.out.print(newArr[i] + " ");
        }
    }

public static int[] copyOfRange(int[] arr, int from, int to) {
    int[] ints = new int[to - from];//3-7 --> 4个
    for (int i = from, j = 0; i < to; i++, j++) {
        ints[j] = arr[i];
    }
    return ints;
}
```

伪造索引解法：自定义index 

```java
public static int[] copyOfRange(int[] arr, int from, int to) {
    int[] ints = new int[to - from];//3-7 --> 4个
    int index = 0;//不在for里面写 自定义索引
    for (int i = from; i < to; i++) {
        ints[index++] = arr[i];
    }
    return ints;
}
```

## 不重复随机数组 - 抽奖 *

直播抽奖，奖品是现金红包，分别有{2,588,888,1000,10000}五个奖金。请使用代码模拟抽奖，打印出每个奖项，奖项的出现顺序要随机且不重复。打印效果如下：（随机顺序，不一定是下面的顺序）

>888元的奖金被抽出
>588元的奖金被抽出
>10000元的奖金被抽出
>1000元的奖金被抽出
>2元的奖金被抽出

**解题思路**

1. 随机索引来代表随机元素，因为索引和元素是一一对应的。
2. 哪些奖被抽过了，哪些奖没有被抽过，要定义一个数组来存放已经被抽过的奖项。
3. 每个奖项只能被抽出一次，要写一个方法来控制奖项不重复。

​	使用数组存放多个奖金，再使用另一个数组存放已经被抽过的奖金，使用方法来判断某个奖金是否已经被抽取过。

**操作步骤**

1. 定义奖金数组arr
2. 创建新方法 传递奖金数组 返回已使用的新数组
3. 新方法逻辑
   1. 随机数
   2. 定义index索引 用于 新数组添加奖金数组值时 叠加length
   3. while循环到 index 等于 奖金数组的Length时结束
   4. 循环 中：判定新数组是否已经包含 要添加进去的值  --> 此处创建新判定方法 返回bool
   5. 如为TRUE 即 已存在 不添加；循环继续
   6. 为FALSE 添加进 并且 index++
4. 创建判定数组中是否包含某数值 的方法 
   1. 传递数组 ， 值
   2. 返回bool  TRUE 存在 / FALSE 不存在

```java
    public static int[] drawLottery(int[] arr) {
        Random ran = new Random();
        int index = 0;
        int[] arrUsed = new int[arr.length];

        while (index < arr.length) {
            int indexRan = ran.nextInt(arr.length);
            if (!isExistNum(arrUsed, arr[indexRan])) {
                arrUsed[index++] = arr[indexRan];
            }
        }

        return arrUsed;
    }
	 /**
     * 判断已使用的数组中是否已存在 该数字
     * @param arrUsed
     * @param num
     * @return TRUE 存在 ; FALSE 不存在
     */
    public static boolean isExistNum(int[] arrUsed, int num) {
        boolean isFlag = false;
        for (int i = 0; i < arrUsed.length; i++) {
            if (arrUsed[i] == num)
                isFlag = true;
        }
        return isFlag;
    }

```

也可以用for循环

# 综合练习

## 打印101~200素数 *

​	判断101~200之间有多少个素数，并输出所有素数。

备注：素数就是质数 只能被1 和它本身整除

```JAVA
public static void main(String[] args) {
    // 外循环 是 需要判断是否为质数的数从101 - 200 都是要判断的
	// 内循环 是 与外循环每一个数 比较%后为0否  为0 代表不是质数 break
	// if判断有多少个TRUE 叠加 输出
    int count = 0;
    for (int i = 101; i < 200; i++) {
    // bool写循环外面会导致： 不会每次刷新为TRUE 执行完一个数后一直为FALSE 就只会执行一次
    // 举例 带入102 走一遍 ，isFlag 被改为 FALSE --> 所以要写循环内 跟随刷新
        boolean isFlag = true;
        for (int j = 2; j < i; j++) {
            if (i % j == 0) {
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            count++;
            System.out.println(i);
        }
    }
    System.out.println("质数有：" + count);
}
```

## 验证码 *

定义方法实现随机产生一个5位的验证码

验证码格式：长度为5；前四位是大写字母或者小写字母； 最后一位是数字

```JAVA
public static void main(String[] args) {
    Random random = new Random();
    char[] character = new char[52];//26个字母 大小写共52个
    //65 - A ; 97 - a
    int smallLetter = 97;
    int capitalLetter = 65;
    String str = ""; //存储合体字母数字

    // 循环用于存储26个字母大小写
    for (int i = 0; i < character.length; i++) {
        if (i <= 25) {
            character[i] = (char) smallLetter++;
        } else {
            character[i] = (char) capitalLetter++;
        }
    }
    
    // 随机生成4个大小写字母
    for (int i = 0; i < 4; i++) {
        int nextInt = random.nextInt(character.length);
        str += character[nextInt];
    }
    int num = random.nextInt(10);
    System.out.println(str += num);
}
```

```JAVA
public static void main(String[] args) {
    Random random = new Random();
    char[] str = new char[52];
    String verificationCode = "";
    for (int i = 0; i < str.length; i++) {
        if (i < 26)
            str[i] = (char) (97 + i);
        else {
            str[i] = (char) (65 + i - 26);
        }
    }

    for (int i = 0; i < 4; i++) {
        int strRandom = random.nextInt(str.length);
        verificationCode += String.valueOf(str[strRandom]);
    }

    int nextInt = random.nextInt(9)+1;

    verificationCode += nextInt;
    System.out.println(verificationCode);
}
```

## 评委打分 *

在唱歌比赛中，有6名评委给选手打分，分数范围是[0 - 100]之间的整数。选手的最后得分为：去掉最高分、最低分后的4个评委的平均分，请完成上述过程并计算出选手的得分。

```java
public static void main(String[] args) {
    int[] arr = getScores();
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i] + " ");
    }
    int sum = getSum(arr);
    int max = getMax(arr);
    int min = getMin(arr);
    int avg = (sum - min - max) / (arr.length - 2);

    System.out.println(" 最大值 " + max + " 最小值 " + min + " 平均值 " + avg + " 总数 " + sum);
}

// 获取总数
public static int getSum(int[] arr) {
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {
        sum += arr[i];
    }
    return sum;
}

// 获取最大值
public static int getMax(int[] arr) {
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (max < arr[i]) {
            max = arr[i];
        }
    }
    return max;
}

// 获取最小值
public static int getMin(int[] arr) {
    int min = arr[0];
    for (int i = 0; i < arr.length; i++) {
        if (min > arr[i]) {
            min = arr[i];
        }
    }
    return min;
}

//输入 获取 6 个 评委的分数
public static int[] getScores() {
    Scanner sc = new Scanner(System.in);
    int index = 0;
    int[] arr = new int[6];

    while (index < 6) {
        System.out.println("打分：");
        int num = sc.nextInt();
        if (num >= 0 && num <= 100) {
            arr[index++] = num;
        } else {
            System.out.println("输入错误！");
        }
    }
    return arr;
}
```

用for 获取 6 分数：i++ 拿出来用

```java
  //1.我要干嘛？定义一个数组，用来存储6名评委的打分（0~100）
    //2.我需要什么？都不需要
    //3.干完了这件事情，是否需要返回？必须返回
    public static int[] getScores(){
        //定义数组
        int[] scores = new int[6];
        //使用键盘录入的形式，输入分数：0~100
        Scanner sc = new Scanner(System.in);
        
        for (int i = 0; i < scores.length; ) {
            System.out.println("请输入评委的打分");
            int score = sc.nextInt();//100
            if(score >=0 && score<= 100){
                scores[i] = score;
                i++;
            }else{
                System.out.println("成绩超出了范围,继续录入，当前的i为：" + i);
            }
        }
        return  scores;
    }
```

## 数字加密

某系统的数字密码（大于0），比如1983，采用加密方式进行传输。

规则如下：

​	先得到每位数，然后每位数都加上5 , 再对10求余，最后将所有数字反转，得到一串新数。

举例：

>​			 1       9       8     3
>
>+5		  6      14 	13	 8
>
>%10	   6  	 4	   3 	 8
>
>反转	   8 	  3  	 4  	6
>
>加密后的结果就是：8346

```JAVA
 /**
     * 数字加密
     * @return
     */
    private static int digitEncryptionFor() {
        Random random = new Random();
        int[] arr = new int[4];
        //4位随机数 存储到 数组 中
        System.out.println("加密前位随机数：");
        for (int i = 0; i < arr.length; i++) {
            int num = random.nextInt(9) + 1;
            arr[i] = num;
            System.out.print(arr[i]);
        }

        System.out.println();

        //开始加密
        //每位数 +5
        for (int i = 0; i < arr.length; i++) {
            arr[i] += 5;
        }

        // 在%10
        for (int i = 0; i < arr.length; i++) {
            arr[i] %= 10;
        }

        // 反转
        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        
        String pwd = "";

        for (int i = 0; i < arr.length; i++) {
            pwd += arr[i];
        }

        System.out.println("加密后：\n"+pwd);

        //int password = 0;
        // 测试 输出 ->  会导致0691 开投为0的数组元素 0没有加上 变成691 -> 使用String+=
        //for (int i = 0; i < arr.length; i++) {
        //    password = password * 10 + arr[i];
        //}
        //System.out.println("加密后：\n"+password);

        return Integer.parseInt(pwd);
    }
```

![image-20231207224228370](https://raw.githubusercontent.com/GavinGroves/Notes/main/img/image-20231207224228370.png)

## 数字解密

```java 
/**
 * 数字解密
 */
private static void digitalDecryption() {
    int password = digitEncryptionFor();//获取加密数字
    int digit = password;
    int num = 0;

    int[] arr = new int[4];
    //一个一个取出 后 存入 数组
    for (int i = 0; i < arr.length; i++) {
        num = digit % 10;
        arr[i] = num;
        digit /= 10;
    }

    int decodeNum = 0;
    //生成解密数据
    for (int i = 0; i < arr.length; i++) {
        decodeNum = decodeNum * 10 + (arr[i] + 5) % 10;
    }
    System.out.println("解密数据："+decodeNum);
}
```

## 双色球

![image-20231207231936486](https://raw.githubusercontent.com/GavinGroves/Notes/main/img/image-20231207231936486.png)

```JAVA
public static void main(String[] args) {
    int[] arrSphere = generateSphere();//生成双色球

    int[] arrInput = inputSphereNumber();//输入双色球号码

    int countRed = 0;
    int countBlue = 0;

    // 生成与输入对比 计数
    for (int i = 0; i < arrSphere.length - 1; i++) {
        boolean isRedFlag = false;
        for (int j = 0; j < arrInput.length - 1; j++) {
            //红
            if (arrSphere[i] == arrInput[j]) {
                isRedFlag = true;
                break;
            }
        }
        if (isRedFlag) {
            countRed++;
        }
    }
    //蓝
    if (arrSphere[arrSphere.length - 1] == arrInput[arrInput.length - 1]){
        countBlue++;
    }

    System.out.println("红球："+countRed);
    System.out.println("蓝球: "+countBlue);

    if(countRed == 6){
        if(countBlue == 1)
            System.out.println("1000万");
        else
            System.out.println("500万");
    } else if (countRed == 5) {
        if(countBlue == 1)
            System.out.println("3000元");
        else
            System.out.println("200元");
    } else if (countRed == 4) {
        if(countBlue == 1)
            System.out.println("200元");
        else
            System.out.println("10元");
    } else if (countRed == 3) {
        if(countBlue == 1)
            System.out.println("10元");
    } else if (countRed == 2) {
        if(countBlue == 1)
            System.out.println("10元");
    } else if (countRed == 1) {
        if(countBlue == 1)
            System.out.println("5元");
    }else if (countRed == 0) {
        if(countBlue == 1)
            System.out.println("5元");
    }
}

/**
 * 输入双色球 6 + 1
 */
private static int[] inputSphereNumber() {
    Scanner sc = new Scanner(System.in);
    int index = 0;
    int[] arr = new int[7];

    // 输入红球
    while (index < arr.length - 1) {
        int enterRedNumber = sc.nextInt();
        if (!isExist(arr, enterRedNumber) && isInputRange(enterRedNumber)) {
            arr[index++] = enterRedNumber;
        }
    }

    // 输入蓝球
    while (true) {
        int enterBlueNumber = sc.nextInt();
        if (enterBlueNumber >= 1 && enterBlueNumber <= 16) {
            arr[arr.length - 1] = enterBlueNumber;
            break;
        }
    }

    //输出测试
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i] + " ");
    }

    return arr;
}

/**
 * 生成双色球
 */
private static int[] generateSphere() {
    Random random = new Random();
    int index = 7;
    int[] arr = new int[index];
    //红球生成
    for (int i = 0; i < arr.length; ) {
        int redNum = random.nextInt(33) + 1;
        if (!isExist(arr, redNum)) {
            arr[i] = redNum;
            i++;
        }
    }

    // 蓝球添加 到最后一个位置
    int blueNum = random.nextInt(16) + 1;
    arr[arr.length - 1] = blueNum;

    //输出测试
    for (int i = 0; i < arr.length; i++) {
        System.out.print(arr[i] + " ");
    }
    return arr;
}

/**
 * 双色球 红1-33 / 蓝1-16  范围限定
 *
 * @param arr
 * @param num
 * @return
 */
private static boolean isInputRange(int num) {
    boolean isFlag = true;

    if (num < 1 || num > 33)
        isFlag = false;

    return isFlag;
}

/**
* 数组中是否存在某个数字
*/
public static boolean isExist(int[] arr, int num) {
    boolean isFlag = false;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == num) {
            isFlag = true;
            break;
        }
    }
    return isFlag;
}
```

# 面向对象综合

## 文字版回合制格斗游戏

​	程序运行之后结果为：

​	姓名为:乔峰		血量为:100	性别为:男	长相为:气宇轩昂

​	姓名为:鸠摩智	血量为:100	性别为:男	长相为:气宇轩昂

​	乔峰使出了一招【背心钉】，转到对方的身后，一掌向鸠摩智背心的灵台穴拍去。给鸠摩智造成一处瘀伤。

​	鸠摩智使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向乔峰。结果乔峰退了半步，毫发无损。 

​	。。。。

​	乔峰K.O.了鸠摩智 

分析：

​	长相是提前定义好的，提前放在一个数组当中，程序运行之后，从数组中随机获取。

![image-20231209201457663](https://raw.githubusercontent.com/GavinGroves/Notes/main/img/image-20231209201457663.png)

### Role

```java
public class Role {
    private String name;
    private int blood;
    private char gender;
    private String face;

    String[] boyfaces = {"风流俊雅", "气宇轩昂", "相貌英俊", "五官端正", "相貌平平", "一塌糊涂", "面目狰狞"};
    String[] girlfaces = {"美奂绝伦", "沉鱼落雁", "婷婷玉立", "身材娇好", "相貌平平", "相貌简陋", "惨不忍睹"};

    //attack 攻击描述：
    String[] attacks_desc = {
            "%s使出了一招【背心钉】，转到对方的身后，一掌向%s背心的灵台穴拍去。",
            "%s使出了一招【游空探爪】，飞起身形自半空中变掌为抓锁向%s。",
            "%s大喝一声，身形下伏，一招【劈雷坠地】，捶向%s双腿。",
            "%s运气于掌，一瞬间掌心变得血红，一式【掌心雷】，推向%s。",
            "%s阴手翻起阳手跟进，一招【没遮拦】，结结实实的捶向%s。",
            "%s上步抢身，招中套招，一招【劈挂连环】，连环攻向%s。"
    };

    //injured 受伤描述：
    String[] injureds_desc = {
            "结果%s退了半步，毫发无损",
            "结果给%s造成一处瘀伤",
            "结果一击命中，%s痛得弯下腰",
            "结果%s痛苦地闷哼了一声，显然受了点内伤",
            "结果%s摇摇晃晃，一跤摔倒在地",
            "结果%s脸色一下变得惨白，连退了好几步",
            "结果『轰』的一声，%s口中鲜血狂喷而出",
            "结果%s一声惨叫，像滩软泥般塌了下去"
    };

    public Role() {
    }

    public Role(String name, int blood, char gender) {
        this.name = name;
        this.blood = blood;
        this.gender = gender;
        this.setFace(gender);
    }

    public void attack(Role attacked) {
        Random random = new Random();
        int damage = random.nextInt(20) + 1;
        int attackIndex = random.nextInt(attacks_desc.length);

        System.out.printf(attacks_desc[attackIndex], this.getName(), attacked.getName());
        System.out.println();

        int attackedBlood = attacked.getBlood() - damage;
        attackedBlood = attackedBlood < 0 ? 0 : attackedBlood;

       attacked.setBlood(attackedBlood);

        if (attackedBlood > 90) {
            System.out.printf(injureds_desc[0], attacked.getName());
        } else if (attackedBlood > 80) {
            System.out.printf(injureds_desc[1], attacked.getName());
        } else if (attackedBlood > 70) {
            System.out.printf(injureds_desc[2], attacked.getName());
        } else if (attackedBlood > 60) {
            System.out.printf(injureds_desc[3], attacked.getName());
        } else if (attackedBlood > 40) {
            System.out.printf(injureds_desc[4], attacked.getName());
        } else if (attackedBlood > 20) {
            System.out.printf(injureds_desc[5], attacked.getName());
        } else if (attackedBlood > 10) {
            System.out.printf(injureds_desc[6], attacked.getName());
        } else {
            System.out.printf(injureds_desc[7], attacked.getName());
        }
        System.out.println();
    }

    public String getFace() {
        return face;
    }

    public void setFace(char gender) {
        Random random = new Random();
        if(gender == '男'){
            int faceIndex = random.nextInt(boyfaces.length);
            this.face = boyfaces[faceIndex];
        }else if (gender == '女'){
            int faceIndex = random.nextInt(girlfaces.length);
            this.face = girlfaces[faceIndex];
        }else{
            this.face = "平平无奇";
        }
    }

    /**
     * 获取
     *
     * @return name
     */
    public String getName() {
        return name;
    }

    /**
     * 设置
     *
     * @param name
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * 获取
     *
     * @return blood
     */
    public int getBlood() {
        return blood;
    }

    /**
     * 设置
     *
     * @param blood
     */
    public void setBlood(int blood) {
        this.blood = blood;
    }

    /**
     * 获取
     *
     * @return gender
     */
    public char getGender() {
        return gender;
    }

    /**
     * 设置
     *
     * @param gender
     */
    public void setGender(char gender) {
        this.gender = gender;
    }

    public void showRoleInfo(){
        System.out.println("姓名为: "+this.getName()+" 血量为: "+this.getBlood()
                +" 性别为: "+this.getGender()+"  长相为: "+ this.getFace());

    }

    public String toString() {
        return "Role{name = " + name + ", blood = " + blood + ", gender = " + gender + "}";
    }
}
```

### Main

```java
public class WordGame {
    public static void main(String[] args) {
        Role yang = new Role("杨过", 100, '男');
        Role dragon = new Role("小龙女", 100, '女');

        System.out.println("——————————开始战斗————————");
        yang.showRoleInfo();
        dragon.showRoleInfo();

        while (true){
            yang.attack(dragon);
            if(dragon.getBlood() == 0){
                System.out.println(yang.getName()+"K.O.了"+dragon.getName());
                break;
            }

            dragon.attack(yang);
            if(yang.getBlood() == 0){
                System.out.println(dragon.getName()+"K.O.了"+yang.getName());
                break;
            }
        }
    }
}
```

## 对象数组的增删改查

定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。

学生的属性：学号，姓名，年龄。

要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。

要求2：添加完毕之后，遍历所有学生信息。

要求3：通过id删除学生信息

​             如果存在，则删除，如果不存在，则提示删除失败。

要求4：删除完毕之后，遍历所有学生信息。

要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁

```java
public class Student {
    private int id;
    private String name;
    private int age;
    ...
```

### 初始化

```JAVA
// 已添加的部分
Student stu1 = new Student(202301, "小张", 17);
Student stu2 = new Student(202302, "小康", 18);
Student stu3 = new Student(202303, "小绿", 18);

Student[] stuArr = {stu1, stu2, stu3};

// 要添加的
Student stu4 = new Student(202304, "小粉", 18);
```

### 封装的方法-查

```JAVA
/*
* 打印遍历数组
*/
public static void printArr(Student[] arr){
    for (int i = 0; i < arr.length; i++) {
        if(arr[i] != null)//打印 非Null元素
            System.out.println(arr[i]);
    }
}

/**
 * 定义一个方法判断数组中已经存了几个元素（不为Null）
 */
public static int getCount(Student[] arr) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] != null) {
            count++;
        }
    }
    return count;
}

/**
 * 判断数组中是否存在某个ID的元素
 *
 * @return bool
 */
public static boolean isExistByID(Student[] arr, int id) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i].getId() == id) {
            return true;
        }
    }
    return false;
}

    /**
     * 通过ID找到存在的元数所对应的索引值
     * @return index存在的元素索引
     */
    public static int getIndexByID(Student[] arr, int id) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != null) {
                int sid = arr[i].getId();
                if (sid == id)
                    return i;
            }
        }
        return -1;
    }
```

### 增

- 判断ID是否已存在
  - 存在 --> 提示已存在
  - 不存在 --> 准备添加ID元素
    - 原数组无空位 添加新元素 --> 1.创建新数组 存放 2.覆盖老数组
    - 原数组有空位(有Null的位置)   直接添加到最后一个位置

```JAVA
        //判断数组中是否存在该ID
        boolean isFlag = isExistByID(arr, stu4.getId());

        if (isFlag) {
            System.out.println("已存在重复ID");
        } else {
            //不存在重复ID --- 可以把stu4添加到数组当中
            int count = getCount(arr);
            if (count == arr.length) {
                //1.数组已经存满 --- 只能创建一个新的数组，新数组的长度 = 老数组 + 1
                arr = createNewArr(arr);
                arr[count] = stu4;

                //打印数组
                printArr(arr);
            } else {
                //2.数组没有存满 --- 直接添加
                //举例 [stu1,stu2,null]
                //getCount获取到的是2，表示数组当中已经有了2个元素
                //还有一层意思：如果下一次要添加数据，就是添加到2索引的位置
                arr[count] = stu4;
                printArr(arr);
            }
        }
```

### 删

```JAVA
        // 删除某ID元素
		//	先判定是否存在该ID元数 --> 存在就返回它的索引	否则为-1不存在索引
        int index = getIndexByID(arr, 1);
        if(index >= 0){
            //存在 --> 为空 
            arr[index] = null;
            // 只会打印不为Null的元数项
            printArr(arr);
        }else{
            System.out.println("不存在该元素！删除失败！");
        }
```

### 改

```JAVA
        //修改某ID的元素 --> 直接拿到索引 修改
        int indexModify = getIndexByID(arr, 2);

        if (indexModify >= 0) {
            Student modifyStu = arr[indexModify];
            modifyStu.setAge(modifyStu.getAge() + 1);
            printArr(arr);
        } else {
            System.out.println("修改失败，不存在ID！");
        }
```









