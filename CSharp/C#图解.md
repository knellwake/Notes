# 第四章  类型、存储和变量

## 4.4 数据成员和函数成员

- 数据成员：保存这个类对象或整个类相关的数据
- 函数成员：定义了这个类/对象的行为逻辑的实现方法细节

## 4.5 预定义类型

C#共16中预定义类型：

> 高精度小数类型 ： **decimal** 类型可以准确地表示分数，常用于货币的计算。

![image-20231024135447925](E:/Typora_MD/Image/image-20231024135447925.png)

## 4.6 用户定义类型

6种：

- 类（class）
- 结构体 （struct）
- 数组 （array）
- 枚举（enum）
- 委托（delegate）
- 接口 （interface）

使用用户定义类型的步骤：先**声明**类型 -> 再**实例化**类型的对象

## 4.7 栈和堆
程序运行时，数据必须存储在内存中。
运行中的程序使用两个**内存区域**来存储数据：*栈和堆*

### 4.7.1 栈

栈是一个内存数组，LIFO（Last-In First-Out，后进先出）的数据结构。

- 数据只能从栈顶执行插入和删除
- 数据放入栈顶 ： **入栈（push）**
- 从栈顶删除：**出栈（pop）**

![image-20231024140941287](E:/Typora_MD/Image/image-20231024140941287.png)

### 4.7.2 堆

堆是一块内存区域，在堆中可以分配大块的内存用于存储数据，堆中能任意顺序存入和删除。

不能显式的删除堆中数据，CLR的GC（自动垃圾回收）判断堆中的某个对象不再被引用使用，就会释放对象。

![image-20231024141501993](E:/Typora_MD/Image/image-20231024141501993.png)

## 4.8 值类型和引用类型

类型决定对象在内存中的存储位置——栈和堆；

- 值类型 存储在栈中，存储实际的数据；
- 引用类型 
  - 引用（地址）存储在栈，这个地址就指向堆中的数据位置
  - 实际数据存储在堆

![image-20231024142018724](E:/Typora_MD/Image/image-20231024142018724.png)

### 4.8.1 存储引用类型对象的成员

如果一个引用类型是另一个对象（类）的成员：

![image-20231024143000761](E:/Typora_MD/Image/image-20231024143000761.png)

引用类型的任何对象，它所有数据成员都存放在堆里，无论它们是值类型还是引用类型！

### 4.8.2 C#类型的分类

![image-20231024142803671](E:/Typora_MD/Image/image-20231024142803671.png)

## 4.9 变量

表示 程序执行时存储在内存中的数据。

4种变量：

- 局部变量        方法作用域内
- 字段                类的成员
- 参数                方法间传递的临时变量
- 数组元素        同类数据项构成有序集合的一个成员

### 4.9.1 变量声明

- 变量命名 并关联一种类型
- 让编译器分配一块内存

![image-20231024144936791](E:/Typora_MD/Image/image-20231024144936791.png)

![image-20231024145410281](E:/Typora_MD/Image/image-20231024145410281.png)

![image-20231024145417176](E:/Typora_MD/Image/image-20231024145417176.png)

局部变量 无默认初始化值，需要赋值后使用。

静态类型：在编译时就确认的变量类型，运行时候不能修改。

动态类型： 变量在运行时才会确认类型，dynamic，需要确保它与变量所代表的实际类型一致，否则会抛出异常；

# 第五章 类的基本概念

运行中的程序是一组相互作用的对象的集合。

## 5.5 创建变量和类的实例

类被声明，就可以创建类的实例。

## 5.6 为数据分配内存

声明类 所分配的内存（栈空间内）是用来保存引用的，

```c#
class Test{} // 声明类

Test test; //声明引用变量
```

保存对象的实际数据（为实际数据分配内存 {堆中}），需要使用new关键字

```c#
Test test = new Test();//声明 并且 初始化
```

- new 运算符 为任意类型的实例分配 并 初始化内存。

![image-20231024161917805](E:/Typora_MD/Image/image-20231024161917805.png)

## 5.7 实例成员

**类**的声明相当于**蓝图**，通过这个蓝图想创建多少个类的实例都可以。

- 实例成员   类的每个实例都是不同的实体。
- 静态成员

## 5.8 访问修饰符

- private         私有 只能总声明它的类内部访问
- public            公有
- protected
- internal
- protected internal

# 第六章 方法

## 6.3 局部变量

- 从声明它的那一刻开始存在；
- 在块内完成执行时结束存在；

![image-20231024163012312](E:/Typora_MD/Image/image-20231024163012312.png)

### 6.3.1 类型推断和var关键字

为避免代码冗余（重复代码），可以使用var关键字；

- 只能用于局部变量，不能用于字段；
- 只能在变量声明并包含初始化时使用；
- 一旦编译器推断出变量的类型，它就是固定不能更改的；

## 6.4 局部常量

- 声明时必须初始化； 初始化值必须在编译期决定。
- 声明后不能改变

```c#
const Type Identifier = Value;
```

可以是Null引用，但是不能是某对象的引用，因为对象的引用是在运行时决定的；

## 6.8 返回语句和void方法

void声明 下 可以使用返回语句 提前退出方法以简化程序逻辑；

```c#
return;
```

## 6.10 参数

- 形参
- 实参

![image-20231024165509185](E:/Typora_MD/Image/image-20231024165509185.png)

## 6.11 值参数

值参数：是把**实参的值复制给形参**；

方法被调用时，系统执行如下：

- 在栈中为形参分配空间
- 将实参复制给形参

引用类型的参数 -> 在栈中的引用（地址）被复制，导致 实参与形参指向同一个对象；-> so: 形参的变化 会 影响 实参

值类型参数 -> 栈中的值 复制 产生一个独立的数据项 -> 形参的变换不影响 实参

## 6.12 引用参数 ref

- 方法的声明和调用中都使用ref修饰符。
- 实参必须是变量，必须被赋值。引用类型的变量可以赋值为Null 或 一个引用；

- 不会在栈上为形参分配内存。
- 形参将变成实参变量的别名，指向相同的内存位置。

## 6.13 引用类型作为值参数 和 引用参数

- **将引用类型对象 作为 值参数 传递**       
  - 如果在方法内创建一个新对象并且赋值给形参，将切断形参与实参之间的关联，
    - 并且在方法调用结束后，新对象也将不复存在；

![image-20231024220735078](E:/Typora_MD/Image/image-20231024220735078.png)

- **引用类型对象 作为 引用参数 传递**
  - 如果在方法内创建一个新对象并且赋值给形参，在方法结束后该对象依然存在，
  - 并且 是实参所引用的值；

![image-20231024221537472](E:/Typora_MD/Image/image-20231024221537472.png)

## 6.14 输出参数 out

用于从方法体内把数据传出到调用代码。

- 方法声明和调用中都使用out修饰符；
- 实参必须是变量，不能是表达式。

输出参数的形参充当实参的别名。形参与实参都是同一块内存位置。

- 在方法内部，给输出参数赋值之后才能读取它。
  - 参数的**初始值无关**，没有必要在方法调用前为实参复制。
- 方法内部，方法返回之前，代码中每条可能的路径都必须为所有输出参数赋值。
  - 因为方法内代码**在读取输出参数之前必须对其写入**，所以**不可能使用输出参数把数据传入方法**。

![image-20231024224217007](E:/Typora_MD/Image/image-20231024224217007.png)

## 6.15 参数数组 params

- 在一个参数列表中只能有一个参数数组
- 如果有，它必须是列表中的最后一个
- 所有参数必须是同类型

**声明**参数数组时：

- params修饰符

- ```c#
  void Test(params int[] inVals){}
  ```

  **数组是一组有序的同类型数据项，*引用类型*；**

注意：

实参传入的对象 是 **值类型** 还是 **引用类型**；

不传递实际的数值，而是自己创建一个数组并且初始化，进行传递，那么编译器会使用我创建的，而不是重新创建一个。

![image-20231024232545546](E:/Typora_MD/Image/image-20231024232545546.png)

# 第七章 深入理解类

## 7.4 静态字段

静态字段被所有类的实例共享，所有类实例都访问同一内存位置。

![image-20231024235723683](E:/Typora_MD/Image/image-20231024235723683.png)

## 7.6 静态函数成员

静态成员函数不能访问实例成员，但能访问其他静态成员。

![image-20231025001835412](E:/Typora_MD/Image/image-20231025001835412.png)

## 7.9 常量与静态量

常量即使没有类实例也可以使用，但与静态量不同，常量没有自己的存储位置，而是在编译时被编译器替换。

![image-20231025002207979](E:/Typora_MD/Image/image-20231025002207979.png)

## 7.10 属性

属性是函数成员；它不一定要为数据存储分配内存！

![image-20231025002937567](E:/Typora_MD/Image/image-20231025002937567.png)

![image-20231025002959965](E:/Typora_MD/Image/image-20231025002959965.png)

- 常见方式：字段private 封装 ， 属性public 来控制从类的外部对字段的访问。

![image-20231025003420958](E:/Typora_MD/Image/image-20231025003420958.png)

- 只有一条语句时候：

![image-20231025003552547](E:/Typora_MD/Image/image-20231025003552547.png)

### 7.10.6 只读和只写属性

![image-20231025003739045](E:/Typora_MD/Image/image-20231025003739045.png)

属性比公有字段更好！

### 7.10.8 计算只读属性实例

属性并非必须和字段关联！

![image-20231025004257428](E:/Typora_MD/Image/image-20231025004257428.png)

![image-20231025004242566](E:/Typora_MD/Image/image-20231025004242566.png)

### 7.10.9 自动实现属性

允许只声明属性，编译器会自动创建隐藏后备字段，并且自动挂载get与set访问器上。

- 不声明后备字段——编译器根据属性的类型分配存储。
- 不能提供访问器的方法体——声明为分号

![image-20231025004955811](E:/Typora_MD/Image/image-20231025004955811.png)

### 7.10.10 静态属性

- 不能访问类的实例成员，但能被实例成员访问
- 不管有无实例，都存在

## 7.11 实例构造函数

在创建类的每个实例时执行。

- 用于初始化类实例的状态
- 类想在外部创建实例，需要public构造

![image-20231025005513160](E:/Typora_MD/Image/image-20231025005513160.png)

### 7.11.1 带参数的构造函数

- 构造函数可以带参数。
- 可以被重载

### 7.11.2 默认构造函数

编译器会默认提供隐式的无参构造；

当你创建类一个有参构造，这个默认无参构造会被顶掉；

## 7.12 静态构造函数

